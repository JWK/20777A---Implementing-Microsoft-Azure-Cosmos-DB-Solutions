# Module 2: Designing and Implementing SQL API Database Applications

- [Module 2: Designing and Implementing SQL API Database Applications](#module-2-designing-and-implementing-sql-api-database-applications)
  - [Lab: Designing and Implementing a Document Database](#lab-designing-and-implementing-a-document-database)
    - [Lab Scenario](#lab-scenario)
    - [Objectives](#objectives)
    - [Lab Setup](#lab-setup)
  - [Exercise 1: Design the Document Structure for the Product Catalog](#exercise-1-design-the-document-structure-for-the-product-catalog)
    - [Exercise 1 Scenario](#exercise-1-scenario)
    - [Task 1: Prepare the Environment](#task-1-prepare-the-environment)
    - [Task 2: Analyze the requirements](#task-2-analyze-the-requirements)
    - [Task 3: Design the Documents and Partitioning Strategy](#task-3-design-the-documents-and-partitioning-strategy)
    - [Task 4: Create a Document Database Using the Cosmos DB SQL API](#task-4-create-a-document-database-using-the-cosmos-db-sql-api)
  - [Exercise 2: Import Data into the SalesData Database](#exercise-2-import-data-into-the-salesdata-database)
    - [Exercise 2 Scenario](#exercise-2-scenario)
    - [Task 1: Import Category and Subcategory Data into the Cosmos DB Database](#task-1-import-category-and-subcategory-data-into-the-cosmos-db-database)
    - [Task 2: Import Product Data into the Cosmos DB Database](#task-2-import-product-data-into-the-cosmos-db-database)
  - [Exercise 3: Querying Product Catalog Information](#exercise-3-querying-product-catalog-information)
    - [Exercise 3 Scenario](#exercise-3-scenario)
    - [Task 1: Create the Adventure-Works Web Application](#task-1-create-the-adventure-works-web-application)
    - [Task 2: Define the Models and ViewModels for the Web Application](#task-2-define-the-models-and-viewmodels-for-the-web-application)
    - [Task 3: Implement a Repository Class that Connects to the Cosmos DB Database](#task-3-implement-a-repository-class-that-connects-to-the-cosmos-db-database)
    - [Task 4: Create the Products Controller and Initial View](#task-4-create-the-products-controller-and-initial-view)
    - [Task 5: Extend the Products Controller to Fetch and Display Product Data](#task-5-extend-the-products-controller-to-fetch-and-display-product-data)
  - [Exercise 4: Maintaining Stock Levels in the Product Catalog](#exercise-4-maintaining-stock-levels-in-the-product-catalog)
    - [Exercise 4 Scenario](#exercise-4-scenario)
    - [Task 1: Create a Collection and Repository for Storing Back Orders](#task-1-create-a-collection-and-repository-for-storing-back-orders)
    - [Task 2: Extend the Repository Class to Enable Document Creation and Update](#task-2-extend-the-repository-class-to-enable-document-creation-and-update)
    - [Task 3: Add Buy Functionality to the Product Details View](#task-3-add-buy-functionality-to-the-product-details-view)
    - [Task 4: Lab close down](#task-4-lab-close-down)
## Lab: Designing and Implementing a Document Database

### Lab Scenario

You have been asked to design an online retail system for a global organization that has thousands of product lines and handles requests from tens of thousands of customers simultaneously.

  - Each customer has his or her own account. The customer account can include personal data (name, shipping addresses, preferred payment methods, security data (for authentication purposes), and other general data).

  - Customers must be able to search the product catalog quickly, searching by keyword, optionally filtering by product category and sub-category, and sorting the results by factors such as price, popularity, review ratings, etc. The system should also give an indication of whether an item is currently in stock.

In this lab, you will design and implement a schema for the product catalog in Cosmos DB.

> **Note**: For simplicity, this lab assumes that you will store the product catalog and product category information in two separate homogenous collections. This is not a best-practice; labs later in the course will use a single heterogenous collection.

### Objectives

At the end of this lab, you should be able to:

  - Design a document schema.

  - Import data into a document collection.

  - Query a document collection.

  - Modify and delete data in a document collection.

### Lab Setup

  - **Estimated time**: 90 minutes
  - **Virtual machine**: 20777A-LON-DEV
  - **User name**: Administrator
  - **Password**: Pa55w.rd

## Exercise 1: Design the Document Structure for the Product Catalog

### Exercise 1 Scenario

The application requires a product catalog; products must be organized by category and sub-category. You will need to consider how to handle product category and sub-category information (including current stock levels). You will also create a SQL API database and collection that matches their design.

Adventure Works Ltd. currently store product information in a SQL Server database running on premises, but are migrating to a Cosmos DB solution running in Azure. Product catalog information is held in a highly normalized in the SQL Server database, as shown in the following image:

![SQL Server Tables holding Product Information](./image1.png)

The main tasks for this exercise are as follows:

1.  Prepare the environment.

2.  Analyze the requirements.

3.  Design the documents and partitioning strategy.

4.  Create a document database using the Cosmos DB SQL API.

### Task 1: Prepare the Environment

1. Using File Explorer, in **E:\\Labfiles\\Lab02\\Starter**, run **Setup.cmd** as **Administrator**.

2. Using the Azure portal, create a new Storage account.
   - Add the account to the **20777\_Mod02** resource group; create this resource group if it does not exist.
   - Create a new blob container. Grant anonymous read access to blobs in the container.
   - Make a note of the **Connection string** for the storage account.

3. Using the Azure portal, create a new Cosmos DB account using the SQL API.
    - Add the account to the **20777\_Mod02** resource group.
    - Create a new database named **SalesData**.
    - Make a note of the **URI** and **Primary Key** of the Cosmos DB account.

### Task 2: Analyze the requirements

While the existing set of tables is excellent for an online transaction processing system, it is not efficient for the query intensive operations required by a retail system, where many thousands of customers distributed around the world could be browsing the catalog simultaneously.

The following query shows the SQL required to retrieve the list of product categories and subcategories:

```SQL
SELECT c.Name AS category, s.Name AS subcategory
FROM Production.ProductCategory c
JOIN Production.ProductSubcategory s
ON s.ProductCategoryID = c.ProductCategoryID
```

The following query shows the SQL required to retrieve the data for each product:

```SQL
SELECT p.ProductID, p.Name, p.ProductNumber, p.Color, p.ListPrice, p.Size, pum.Name As SizeUnit,
        p.Weight, pw.Name As WeightUnit, psc.Name As SubcategoryName, pc.Name As CategoryName, i.Quantity,
        d.Title, d.DocumentSummary, d.Document, d.FileName AS DocumentFileName, pm.Name AS ModelName,ill.Diagram,
        ph.ThumbnailPhoto, ph.ThumbnailPhotoFileName, ph.LargePhoto, ph.LargePhotoFileName, pds.Description
FROM Production.Product p
LEFT JOIN Production.ProductSubcategory psc
ON p.ProductSubCategoryID = psc.ProductSubcategoryID
LEFT JOIN Production.ProductCategory pc
ON psc.ProductCategoryID = pc.ProductCategoryID
LEFT JOIN(SELECT ProductID, SUM(Quantity) AS Quantity FROM Production.ProductInventory GROUP BY ProductID) AS i
ON p.ProductID = i.ProductID
LEFT JOIN Production.UnitMeasure pum
ON p.SizeUnitMeasureCode = pum.UnitMeasureCode
LEFT JOIN Production.UnitMeasure pw
ON p.WeightUnitMeasureCode = pw.UnitMeasureCode
LEFT JOIN  Production.ProductDocument pd
ON p.ProductID = pd.ProductID
LEFT JOIN Production.Document d
ON pd.DocumentNode = d.DocumentNode
LEFT JOIN Production.ProductModel pm
ON p.ProductModelID = pm.ProductModelID
LEFT JOIN Production.ProductModelIllustration pmi
ON pm.ProductModelID = pmi.ProductModelID
LEFT JOIN Production.Illustration ill
ON pmi.IllustrationID = ill.IllustrationID
LEFT JOIN Production.ProductProductPhoto ppp
ON P.ProductID = ppp.ProductID
LEFT JOIN Production.ProductPhoto ph
ON ppp.ProductPhotoID = ph.ProductPhotoID
LEFT JOIN Production.ProductModelProductDescriptionCulture pmdc
ON pm.ProductModelID = pmdc.ProductModelID AND pmdc.CultureID = 'en'
LEFT JOIN Production.ProductDescription pds
ON pmdc.ProductDescriptionID = pds.ProductDescriptionID
```

The document design for Cosmos DB should reflect a denormalized strategy that reduces search and response times for queries. Specifically, Adventure-Works requires a design that supports the following queries:

  - List category/subcategory groups

  - List products by category/subcategory

  - Find products by model name

  - Find products by name

  - Find products by product number

### Task 3: Design the Documents and Partitioning Strategy

The database administrator has provided you with a copy of the production SQL Server database with anonymized personally identifying information. Before you start to design your documents, you will open the database using the **(localdb)** SQL Server instance installed with Visual Studio.

1.  In Visual Studio, use **Server Explorer** to open **AdventureWorks2016\_Data.mdf** in **E:\\Labfiles\\Lab02\\Data**.

2.  Run the SQL query given for category/subcategory listings in **Task 1** above, then design a document structure for category/subcategory groups.

3.  Run the SQL query for product information given in **Task 1** above. Examine the output, then design a document structure for the information.

    **Question**: What different approaches to the document design did you consider; what are their advantages and disadvantages?
    
    **Question**: Will you store all the documents in one collection, or use more than one collection?
    
    **Question**: The product data includes binary information in the form of Word documents and image files. How will you accommodate these files in Cosmos DB?

4.  Identify a partitioning strategy for the product data.

    **Question**: Assuming that the collection was going to scale to many millions of products, how would you partition the products collection?
    
    **Question**: Will the product category/subcategory documents benefit from partitioning?

### Task 4: Create a Document Database Using the Cosmos DB SQL API

1.  Add a new collection named **ProductCatalog** to the **SalesData** database. Use unlimited storage, and **1000** RU/s throughput. Specify the partitioning key that you have selected. Specify **/productnumber** as the unique key.

2.  Add a new collection named **ProductCategories** to the **SalesData** database. Use fixed storage and **1000** RU/s throughput. Specify **/subcategory** as the unique key.

>**Result**: At the end of this exercise, you should have created a database and collection to hold the product catalog, and designed the document schema.

## Exercise 2: Import Data into the SalesData Database

### Exercise 2 Scenario

The main tasks for this exercise are as follows:

1.  Import category and subcategory data into the Cosmos DB database.

2.  Import product data into the Cosmos DB database.

### Task 1: Import Category and Subcategory Data into the Cosmos DB Database

1.  Query the **AdventureWorks** database to generate a JSON file of the category/subcategory data. Save the file as **E:\\Labfiles\\Lab02\\categories.json**. Use this query as a basis for your file:

    ```SQL 
    SELECT c.Name AS category, s.Name AS subcategory
    FROM Production.ProductCategory c
    JOIN Production.ProductSubcategory s
    ON s.ProductCategoryID = c.ProductCategoryID
    FOR json path
    ```

2.  Using the Azure Portal Data Explorer, upload the **categories.json** file that you created in the last step to the **ProductCategories** collection.

3.  Verify that 38 rows were added to the collection.

### Task 2: Import Product Data into the Cosmos DB Database

The product data is more complex than the category/subcategory information; the target document structure contains subdocuments, and some information—such as images and other illustrations—must be uploaded to blob storage and linked from the product documents. For these reasons, the developers at Adventure Works have decided to create a custom application to retrieve the data from SQL Server, format it, and upload it to the ProductCatalog collection using the SQL API.

1.  Open the the **MigrateProductData** solution in **E:\\Labfiles\\Lab02\\Starter\\MigrateProductData**.

2.  Edit the **App.config** file. Set the **EndpointUrl** and **PrimaryKey** settings to the values you recorded for the Cosmos DB account in **Exercise 1** above. Set the **BlobStorageConnectionString** and **BlobContainer** settings to the values for your storage account in **Exercise 1** above.

3.  Open the **Program.cs** file. This file contains the skeleton of the application. When it is complete, the **DoLoad** method will retrieve the data from SQL Server, create and format a new document for each row, upload the binary data in the row into blob storage, and then add the row (now containing references to the binary data in the form of blob storage URLs) to the **ProductCatalog** collection.
    
      - The helper method, **GetData** runs the SQL Server query shown earlier in this lab and returns a **SqlDataReader** object for fetching the data a row at a time.
    
      - You will use the **UploadDataToBlobStorageAsync** method to store the binary data for an item in blob storage.
    
      - The **UploadDocumentToCosmosD** method will save the document to the collection in Cosmos DB.

4.  Edit the **Product.cs** file. You will define the structure of the documents and subdocuments required for the Cosmos DB database in this file.
    
    1.  At the comment **TODO: Specify fields for the Product document** add a class definition for your **Product** document that you designed in **Exercise 1**.
    
    2.  At the comment **TODO: Specify fields for the ProductCategoryData subdocument** add a class definition for your **ProductCategoryData** subdocument.
    
    3.  At the comment **TODO: Specify fields for the ProductDocumentData subdocument** add a class definition for your **ProductDocumentData** subdocument.
    
    4.  At the comment **TODO: Specify fields for the ProductImageData subdocument** add a class definition for your **ProductImageData** subdocument.

5.  Edit the **Program.cs** file:
    
    1.  At the comment **TODO: Create a client to connect to the Cosmos DB database** add a statement to create a new instance of the **DocumentClient** class called **client**. Use the **endpointURL** and **primaryKey** string variables to configure the instance.
    
    2.  At the comment **TODO: Connect to Azure Blob Storage** add the following code to create a connection to your blob container using the Windows Azure Storage API:
    
  
        ```csharp 
        if (!CloudStorageAccount.TryParse(this.blobStorageConnectionString, out CloudStorageAccount storageAccount))
        {
            Console.WriteLine("Invalid storage connection string");
            return;
        }
        this.blobClient = storageAccount.CreateCloudBlobClient();
        ```
    
    3.  At the comment **TODO: Create a document from the current row retrieved from SQL Server** add code to create a new instance of the **Product** class called **productDocument** populated from the properties of a row in the result set returned by the SQL Server product query, held in the **reader** object. If necessary, use the **UploadDataToBlobStorageAsync** method to upload data to blob storage.
    
    4.  At the comment **TODO: Upload the document to the collection in Cosmos DB** add the following code to upload the document object to Cosmos DB:
      
        ```csharp 
        if (await UploadDocumentToCosmosDB(productDocument))
        {
            Console.WriteLine($"Added document {productDocument.ProductID} for {productDocument.ProductName}: {productDocument.Description}");
        }
        else
        {
            Console.WriteLine($"Upload failed for {productDocument.ProductID}: {productDocument.ProductName}");
        }
        ```
        
        > **Note**: This block calls the **UploadDocumentToCosmosDB** helper method to save the document to Cosmos DB. The **UploadDocumentToCosmosDB** method returns a boolean value indicating whether the document was saved successfully or not.
    
    5.  At the comment **TODO: If the data is NULL, return an empty string**. Add the following code after this comment. Note all products have images or other associated binary data, and in this case the data retrieved from SQL Server will be **DBNull**. This code simply returns an empty string for these situations, and the corresponding field in the **Product** document will be empty:
    
        ```csharp 
        if (string.Compare(data.GetType().Name, "DBNull") == 0)
        {
            return string.Empty;
        }
        ```
    
    6.  After the comment **TODO: Otherwise cast the data into a byte array**, add the following statement. This conversion is necessary because the Azure Storage API expects binary data to be passed as a stream of bytes:
    
        ```csharp 
        var byteData = data as byte[];
        ```
        
    7.  At the comment **TODO: If the cast failed, the data probably contains a string, so use GetBytes to convert it into a byte array**, add the following statement. Some of the binary data in the SQL Server database is stored as strings. In this case, the previous cast will fail and the **byteData** array will be **null**. This code handles the situation by converting the string into a byte array:
    
        ```csharp 
        if (byteData == null)
        {
            byteData = Encoding.ASCII.GetBytes(data.ToString());
        }
        ```
    
    8.  At the comment **TODO: Get a reference to the blob container and a blob in Azure storage. The blob will hold the data being uploaded**, add the statements shown below. This code uses the Azure Storage API to obtain a reference to your blob storage container:
    
        ```csharp 
        var cloudBlobContainer = this.blobClient.GetContainerReference(this.blobContainer);
        var blockBlob = cloudBlobContainer.GetBlockBlobReference(name);
        ```
    
    9.  At the comment **TODO: Upload the data to the blob**, add the following statement. This statement streams the data from the byte array into the blob:
    
        ```csharp 
        await blockBlob.UploadFromByteArrayAsync(byteData, 0, byteData.Length);
        ```
    
    10. At the comment **TODO: Return the URI of the new blob as a string**, add the following statement which obtains the URL of the newly created blob and returns it to the caller:
    
        ```csharp
        return blockBlob.Uri.ToString();
        ```
        
    11. At the comment **TODO: Add the document to the Cosmos DB database**, add the following statements. This code uses the SQL API to add the document to the collection in Cosmos DB. It examines the status code returned by the operation. If it is **Created** then the method returns **true** to indicate that the document was uploaded successfully. If the status has some other value, then the upload must have failed and the method returns **false**:

        ```csharp 
        Uri productCollection = UriFactory.CreateDocumentCollectionUri(this.database, this.collection);
        var response = await this.client.CreateDocumentAsync(productCollection, productDocument);
        return (response.StatusCode == System.Net.HttpStatusCode.Created);
        ```
        
6.  Build and run the application. Verify that it retrieves the data from SQL Server and uploads the documents to Cosmos DB without reporting any errors.

7.  Using the Azure portal, go to Data Explorer for the **ProductCatalog** collection and examine some of the documents. Click the link for any of the images—they should be displayed by the browser.

**Result**: At the end of this exercise, you should have populated your Cosmos DB database with product catalog information.

## Exercise 3: Querying Product Catalog Information

### Exercise 3 Scenario

Customers will browse the product catalog by using a web application. The application will enable customers to search for products by category, subcategory, name, model, or product number—as described in the list of requirements at the start of this lab. You will build this web application in this exercise.

The main tasks for this exercise are as follows:

  - Create the Adventure-Works web Application.

  - Define the models and view models for the web application.

  - Implement a repository class that connects to the Cosmos DB database.

  - Create the products controller and initial view.

  - Extend the products controller to fetch and display product data.

### Task 1: Create the Adventure-Works Web Application

  - In Visual Studio, create a new project using the **ASP.NET Web Application (.NET framework)** template. Call the project **Adventure-Works** and use the location **E:\\Labfiles\\Lab02**.
    
    1.  In the **New ASP.NET Web Application** dialog box, select **MVC**.
    
    2.  On the **Tools** menu, click **NuGet Package Manager**, and then click **Manage NuGet Packages for Solution**.
    
    3.  On the **Browse** tab, enter **DocumentDB**, select **Microsoft.Azure.DocumentDB**, and add the package to the project.
    
    4.  On the **Updates** tab, install any updates for out-of-date packages.

### Task 2: Define the Models and ViewModels for the Web Application

1.  Add a new C\# class to the **Models** folder. Name the class file **Product.cs**.

2.  Add the same class definitions that you used in the data import application to the **Product.cs** file. These are the same classes that you used to migrate the data to Cosmos DB, and they specify the structure of the documents and subdocuments in the **ProductCatalog** collection. Add definitions for **Product**, **ProductCategoryData**, **ProductDocumentData**, and **ProductImageData**.

3.  Add the following **using** directive to the list at the top of the file. The **JsonProperty** attribute is defined in this namespace:

    ```csharp 
    using Newtonsoft.Json;
    ```

4.  Add another class file to the **Models** folder, named **ViewModels.cs**.

5.  In the **ViewModels.cs** file, replace the **ViewModels** class with the following class definitions. You will use these classes to work with the MVC framework to display data and retrieve user input:

    ```csharp 
    public class ProductCategoryViewModel
    {
        public string CategoryName { get; set; }
        public IEnumerable<SelectListItem> Categories { get; set; }
    }

    public class ProductSubcategoryViewModel
    {
        public string SubcategoryName { get; set; }
        public IEnumerable<SelectListItem> Subcategories { get; set; }
    }

    public class ProductViewModel
    {
        public string SearchString { get; set; }
        public IEnumerable<Product> Products { get; set; }
        public ProductCategoryViewModel SelectableCategories { get; set; }
        public ProductSubcategoryViewModel SelectableSubcategories { get; set; }
    }
    ```

6.  Add the following **using** directive to the list at the top of the file:

    ```csharp 
    using System.Web.Mvc;
    ```
    
    This namespace contains the **SelectListItem** class used by the MVC framework to support drop-down lists. In this application, you will use drop-down lists to display catagory and subcategory information. The item the customer selects will be transferred to the **CategoryName** or **SubcategoryName** fields in the corresponding class by the MVC framework. The **ProductViewModel** class incorporates **ProductCategoryViewModel** and **ProductSubcategoryViewModel** objects, together with a text field named **SearchString**. If the customer searches for products by name, number, or model, the MVC framework will populate this field with the search text provided by the customer.

### Task 3: Implement a Repository Class that Connects to the Cosmos DB Database

The application will use the Repository Pattern to implement the data access layer. The repository class will be a generic type that the application will use to retrieve data from the collections in the database.

1.  Add a new class to the root folder of the project, named **ProductsRepository.cs**.

2.  In the **ProductsRepository.cs** file, change the **ProductsRepository** class to a static class that takes a single type parameter, **T**; at runtime, you will create different instances of this repository to handle the **ProductCatalog** and **ProductCategories** collections:

    ```csharp 
    public static class ProductsRepository<T>
    {
    }
    ```
3.  Add the *using* directives shown below to the list at the top of the file:

    ```csharp 
    using Microsoft.Azure.Documents.Client;
    using Microsoft.Azure.Documents.Linq;
    using System.Configuration;
    using System.Linq.Expressions;
    using System.Threading.Tasks;
    ```

4.  Add the following static fields to the **ProductsRepository\<T>** class. You will use these fields to hold the parameters and objects required to connect to the database and collection:

    ```csharp 
    private static string endpointUrl;
    private static string primaryKey;
    private static string database;
    private static string collection;
    private static DocumentClient client;
    ```

5.  Add the static **Initialize** method shown below to the **ProductsRepository\<T>** class. This method initializes the fields just defined using settings from the **Web.config** file, and creates a **DocumentClient** object that this class will use to connect to the database:

    ```csharp 
    public static void Initialize(string coll)
    {
        endpointUrl = ConfigurationManager.AppSettings["EndpointUrl"];
        primaryKey = ConfigurationManager.AppSettings["PrimaryKey"];
        database = ConfigurationManager.AppSettings["Database"];
        collection = coll;
        client = new DocumentClient(new Uri(endpointUrl), primaryKey);
    }
    ```

6.  Add the following method to the **ProductsRepository\<T>** class. This method creates and runs a query that fetches all documents from a collection. The documents are retrieved in list, and the list is returned by the method:

    ```csharp 
    public static async Task<IEnumerable<T>> GetAllItemsAsync()
    {
        // Find all documents in the collection
        IDocumentQuery<T> query = client.CreateDocumentQuery<T>(
            UriFactory.CreateDocumentCollectionUri(database, collection))
            .AsDocumentQuery();
    
        // Return the documents as a list
        List<T> results = new List<T>();
        while (query.HasMoreResults)
        {
            results.AddRange(await query.ExecuteNextAsync<T>());
        }
    
        return results;
    }
    ```

7.  Add the method shown below to the **ProductsRepository\<T>** class. This method creates and runs a query that fetches only those documents that match the expression passed in as the parameter. As before, the documents are retrieved in list, and the list is returned by the method:

    ```csharp 
    public static async Task<IEnumerable<T>> GetItemsAsync(Expression<Func<T, bool>> predicate)
    {
        // Find all documents in the collection that match the predicate
        IDocumentQuery<T> query = client.CreateDocumentQuery<T>(
            UriFactory.CreateDocumentCollectionUri(database, collection),
            new FeedOptions { EnableCrossPartitionQuery = true })
            .Where(predicate)
            .AsDocumentQuery();
    
        // Return the matching documents as a list
        List<T> results = new List<T>();
        while (query.HasMoreResults)
        {
            results.AddRange(await query.ExecuteNextAsync<T>());
        }
    
        return results;
    }
    ```

8.  Open the **Web.config** file and add the following settings to the **appSettings** section. Replace **\<URL>** with the URL of your Cosmos DB account and replace **\<PRIMARY KEY>** with the primary key of the account:

    ```csharp 
    <configuration>
    <appSettings>
        <add key="EndpointUrl" value="<URL>" />
        <add key="PrimaryKey" value="<PRIMARY KEY>" />
        <add key="Database" value="SalesData" />
        <add key="ProductsCollection" value="ProductCatalog" />
        <add key="CategoriesCollection" value="ProductCategories" />
        ...
    </appSettings>
    ...
    ...
    </configuration>
    ```

9.  Edit the **global.asax** file for the application and add the following two statements to the end of the **Application_Start** method. These statements initialize two instances of the repository; one for the **ProductCatalog** collection and the other for the **ProductCategories** collection:

    ```csharp 
    protected void Application_Start()
    {
        ...
        ProductsRepository<Adventure_Works.Models.Product>.Initialize(ConfigurationManager.AppSettings["ProductsCollection"]);
        ProductsRepository<Adventure_Works.Models.ProductCategoryData>.Initialize(ConfigurationManager.AppSettings["CategoriesCollection"]);
    }
    ```

10. Add the following **using** directive to the list of the top of the **global.asax** file:

    ```csharp
    using System.Configuration;
    ```

### Task 4: Create the Products Controller and Initial View

The application will use the **Products** controller to manage the interactions between the customer and the database. The controller will present data to the customer using a series of views.

1.  Add a controller to the **Controllers** folder. Select the **MVC 5 Controller - Empty** template, and name the controller **ProductsController**.

2.  Add the following **using** directives to the list at the top of the **ProductsController.cs** file:

    ```csharp 
    using Adventure_Works.Models;
    using System.Threading.Tasks;
    ```

3.  In the **ProductsController** class, create the **InitializeCategoryDataAsync** method shown below:

    ```csharp 
    private async Task<IEnumerable<ProductCategoryData>> InitializeCategoryDataAsync()
    {
        // Retrieve the list of categories and subcategories from the document database
        var categoryData = await ProductsRepository<ProductCategoryData>.GetAllItemsAsync();
        Session["categoryData"] = categoryData;
        return categoryData;
    }
    ```
    
    This method uses the **ProductCategoryData** repository to fetch all category (and subcategory) information, and then caches it locally in session memory. The volume of data in this collection is small and can easily be retained in memory. It is also very slow moving (category and subcategory information rarely changes). Caching the data in this way means that the same data does not have to be fetched repeatedly in the user's session.

4.  Add the following method to the **ProductsController** class:

    ```csharp 
    private async Task<ProductCategoryViewModel> InitializeCategoriesAsync()
    {
        // Construct the ProductCategoryViewModel data using the data retrieved from the document database 
        var categoryData = Session["categoryData"] as IEnumerable<ProductCategoryData> ?? await ProductsRepository<ProductCategoryData>.GetAllItemsAsync();
        var distinctCategories = (from c in categoryData select c.Category).Distinct();
        var selectableCategories = new ProductCategoryViewModel { Categories = from c in distinctCategories select new SelectListItem { Text = c, Value = c } };
        Session["selectableCategories"] = selectableCategories;
        return selectableCategories;
    }
    ```
    
    This code takes the category data and uses it to populate the **ProductCategoryViewModel** that the MVC framework will use to display product categories to the user. Again, this data is cached in the session. Note that this code uses a LINQ query that eliminates duplicate entries for the same category (each category is repeated for every subcategory that it contains in the **ProductCategories** collection in the Cosmos DB database).

5.  Add the method shown below to the **ProductsController** class. This method populates the **ProductSubcategoryViewModel** object used by the MVC framework to display subcategory information:

    ```csharp 
    private async Task<ProductSubcategoryViewModel> InitializeSubCategoriesAsync()
    {
        // Construct the ProductSubcategoryViewModel data using the data retrieved from the document database
        var categoryData = Session["categoryData"] as IEnumerable<ProductCategoryData> ?? await ProductsRepository<ProductCategoryData>.GetAllItemsAsync();
        var subcategoryData = (from c in categoryData select c.Subcategory);
        var selectableSubcategories = new ProductSubcategoryViewModel { Subcategories = from s in subcategoryData select new SelectListItem { Text = s, Value = s } };
        Session["selectableSubcategories"] = selectableSubcategories;
        return selectableSubcategories;
    }
    ```

6.  Delete the following method from the **ProductsController** class:

    ```csharp 
    // GET: Products
    public ActionResult Index()
    {
        return View();
    }
    ```

7.  Add the **FindProductsAsync** method shown below to the **ProductsController** class:

    ```csharp 
    // Initial, default action for the form
    [ActionName("FindProducts")]
    [HttpGet]
    public async Task<ActionResult> FindProductsAsync()
    {
        // Build and display an initial view model containing just the list of categories and subcategories (don't display all products by default as there could be a lot of them)
        return View(new ProductViewModel
        {
            Products = new List<Product>(),
            SelectableCategories = Session["selectableCategories"] as ProductCategoryViewModel ?? await InitializeCategoriesAsync(),
            SelectableSubcategories = Session["selectableSubcategories"] as ProductSubcategoryViewModel ?? await InitializeSubCategoriesAsync()
        });
    }
    ```
    
    This method creates a **ProductsViewModel** object, populating the **SelectableCategories** and **SelectableSubcategories** fields with the data retrieved and cached by the code shown in the previous steps. Note that the list of products in the view model is left empty initially; there could be a lot of products in the database, and some aspects (such as the number in stock) can change frequently, so populating and caching this list would not be beneficial at this time. After constructing the view model, this method creates a view that is used to display it.

8.  Add a view to the **Products** folder in the **Views** folder. Set the name to **FindProducts** (this name should match that of the method in the **ProductsController** that creates it). Select the **Empty (without model)** template, select the **Use a layout page** option, and specify the **\~/Views/Shared/\_Layout.cshtml** layout page.

9.  In the **FindProducts.cshtml** file, add the following code to the top of the file. This code specifies the type of the object that will provide the data to display in this view:

    ```HTML 
    @model Adventure_Works.Models.ProductViewModel
    ```

10. Change the page heading as follows:

    ```HTML 
    <h1>Product Catalog</h1>
    ```

11. Add the following HTML markup and Razor code immediately after the page heading:

    ```HTML 
    <div class="panel panel-default">
        <div class="panel panel-body">
    
            @using (Html.BeginForm("FindProducts", "Products", FormMethod.Post, new { role = "form" }))
            {
                <div class="form-group">
                    <h2>Categories</h2>
                    @Html.DropDownListFor(c => c.SelectableCategories.CategoryName, new SelectList(Model.SelectableCategories.Categories, "Text", "Value"), new { @class = "form-control" })
                </div>
                <p>
                    <button type="submit" class="btn btn-primary">Search By Category</button>
                </p>
            }
    
            @using (Html.BeginForm("FindProducts", "Products", FormMethod.Post, new { role = "form" }))
            {
                <div class="form-group">
                    <h2>Subcategories</h2>
                    @Html.DropDownListFor(s => s.SelectableSubcategories.SubcategoryName, new SelectList(Model.SelectableSubcategories.Subcategories, "Text", "Value"), new { @class = "form-control" })
                </div>
                <p>
                    <button type="submit" class="btn btn-primary">Search By Subcategory</button>
                </p>
            }
    
            @using (Html.BeginForm("FindProducts", "Products", FormMethod.Post, new { role = "form" }))
            {
                <div class="form-group">
                    <h2>Product Name, Model Name, or Product Number</h2>
                    @Html.TextBoxFor(t => t.SearchString, new { @class = "form-control" })
                </div>
                <p>
                    <button type="submit" class="btn btn-primary">Search By Product Name, Model Name, or Product Number</button>
                </p>
            }
    
            <!--TODO: Table showing matching products/-->
    
        </div>
    </div>
    ```
    
    This code creates three HTML forms:
    
    1.  The first form uses the **Html.DropDownList** function to create a drop-down list containing the categories. When the user selects an item from this list, the MVC runtime will fill the **CategoryName** field of the view model with the name of the category.
    
    2.  The second form is similar, except that it displays a drop-down list of subcategories. The MVC runtime will store the selected subcategory name in the **SubcategoryName** field of the view model.
    
    3.  The third form just contains a text box into which the user can enter a product name, number, or model. The value input by the user is stored in the **SearchString** field of the view model.
    
    In all cases the form also displays a button that sends an HTTP Post request back to the controller. The Post request is routed to the **FindProducts** method in the controller.

12. In Solution Explorer, right-click the **Adventure-Works** project (not the solution) and then click **Properties**.

13. On the **Web** tab under **Start Action**, select **Specific Page**, but leave the page name empty. Save the file.

14. In the **App\_Start** folder, edit the **RouteConfig.cs** file. In the **RegisterRoute** method, add the following statement before the code that specifies the **Default** route. This code causes the **ProductsController** to run by default when the user connects to the web site:

    ```csharp 
    routes.MapRoute(
        name: "Home",
        url: "",
        defaults: new { controller = "Products", action = "FindProducts" }
    );
    ```

15. Edit the **\_Layout.cshtml** file in the **Views/Shared** folder. In this file:
    
    1.  Set the **\<title>** to **Adventure-Works Cycles**.
    
    2.  Set the title in **Html.ActionLink** action in the navigation bar header to **Adventure-Works Product Catalog**.
    
    3.  Set the **\<footer>** message to **@DateTime.Now.Year - Adventure-Works Cycles**.

    4. The code below shows the complete file after these changes are made:
    ```HTML    
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>@ViewBag.Title Adventure-Works Cycles</title>
        @Styles.Render("~/Content/css")
        @Scripts.Render("~/bundles/modernizr")
    </head>
    <body>
        <div class="navbar navbar-inverse navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    @Html.ActionLink("Adventure-Works Product Catalog", "Index", "Home", new { area = "" }, new { @class = "navbar-brand" })
                </div>
                <div class="navbar-collapse collapse">
                    <ul class="nav navbar-nav">
                        <li>@Html.ActionLink("Home", "Index", "Home")</li>
                        <li>@Html.ActionLink("Catalog", "FindProducts", "Products")</li>
                        <li>@Html.ActionLink("About", "About", "Home")</li>
                        <li>@Html.ActionLink("Contact", "Contact", "Home")</li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="container body-content">
            @RenderBody()
            <hr />
            <footer>
                <p>&copy; @DateTime.Now.Year - Adventure-Works Cycles</p>
            </footer>
        </div>

        @Scripts.Render("~/bundles/jquery")
        @Scripts.Render("~/bundles/bootstrap")
        @RenderSection("scripts", required: false)
    </body>
    </html>
    ```

16. Build and run the web application. Verify that the **Product Catalog** page appears. The **Categories** and **Subcategories** lists should be populated (click the drop-down lists to see the data). Note that if you click any of the buttons, you will currently receive an error because you have not implemented the code that handles the POST request yet. Close the web application.

### Task 5: Extend the Products Controller to Fetch and Display Product Data

1.  Edit the **ProductsController** class and add the following overload for the **FindProductsAsync** method:

    ```csharp 
    // Method called as POST request from the various search buttons on the form
    [ActionName("FindProducts")]
    [HttpPost]
    public async Task<ActionResult> FindProductsAsync(ProductViewModel productViewModel)
    {
        // Construct a view model that matches the search criteria specified by the user
    
        IEnumerable<Product> products = null;
    
        if (productViewModel.SelectableCategories != null)
        {
            // User is searching by category
            products = await ProductsRepository<Product>.GetItemsAsync(p => p.ProductCategory.Category == productViewModel.SelectableCategories.CategoryName);
        }
        else if (productViewModel.SelectableSubcategories != null)
        {
            // User is searching by subcategory
            products = await ProductsRepository<Product>.GetItemsAsync(p => p.ProductCategory.Subcategory == productViewModel.SelectableSubcategories.SubcategoryName);
        }
        else
        {
            // User is searching by product name, model name, or product number
            products = await ProductsRepository<Product>.GetItemsAsync(p => 
                p.ProductName.Contains(productViewModel.SearchString) ||
                p.Model.Contains(productViewModel.SearchString) ||
                p.ProductNumber.Contains(productViewModel.SearchString));
        }
    
        // Construct a new view model containing the results and display it
        return View(new ProductViewModel
        {
            Products = products,
            SelectableCategories = Session["selectableCategories"] as ProductCategoryViewModel ?? await InitializeCategoriesAsync(),
            SelectableSubcategories = Session["selectableSubcategories"] as ProductSubcategoryViewModel ?? await InitializeSubCategoriesAsync()
        });
    }
    ```
    
    This version of the method responds to the POST request from the view. The method examines the values in the **SelectableCategories**, **SelectableSubcategories**, and **SearchString** fields in the view model (only one of them will contain any data, depending on which button the user clicked in the view). The method then uses this information to populate the **Products** list in the view model with a list of products in the specified category or subcategory, or that match the name, number, or model of the product. Finally, the method constructs a new instance of the view model with this data which it sends back to the view for display.

2.  Edit the **FindProducts.cshtml** file. Replace the **\<!--TODO: Table showing matching products/-->** markup in the view with the following code:

    ```HTML 
    <table class="table">
        <thead>
            <tr>
                <td>Product Number</td>
                <td>Product Name</td>
                <td>Model</td>
                <td></td>
            </tr>
        </thead>
        @foreach (var item in Model.Products)
        {
            <tr>
                <td>
                    @Html.DisplayFor(modelItem => item.ProductNumber)
                </td>
                <td>
                    @Html.DisplayFor(modelItem => item.ProductName)
                </td>
                <td>
                    @Html.DisplayFor(modelItem => item.Model)
                </td>
                <td>
                    @Html.ActionLink("Details", "GetProductDetails", new { productID = item.ProductID })
                </td>
            </tr>
        }
    </table>
    ```
    
    This code creates an HTML table that displays the data in the Products list in the view model. If this list is empty, no data is displayed. The table also includes a link named **Details**. The intention is that if the user clicks this link, they will be presented with the full details of the selected product (you will implement this functionality shortly).

3.  Build and run the web application.
    
      - From the **Categories** list, pick a category, and then click **Search By Category**. The view should now display all products that match that category.
    
      - In the **Subcategories** list, select a subcategory, and then click **Search By Subcategory**. This time the view should display only those products in that subcategory.
    
      - In the **Product Name, Model Name, or Product Number** text box, type **Wash**, and then click **Search By Product Name, Model Name, or Product Number**. You should now be presented with all products that contain the text **Wash** in the product number, name, or model. Note that this search is case-sensitive.
    
      - If you click the **Details** link for a product, the application will currently report an error because you haven't implemented the **GetProductDetails** method yet.

4.  Close the web application and return to Visual Studio.

5.  Add the **GetProductDetailsAsync** method shown below to the **ProductsController** class. This method takes the ID of he product selected by the customer when they click the **Details** link, uses the repository to fetch the details of the specified product, and then displays it in another view:

    ```csharp 
    // Method called to display the details of the specified product
    [ActionName("GetProductDetails")]
    [HttpGet]
    public async Task<ActionResult> GetProductDetailsAsync(string productID)
    {
        // Find the data for the specified product
        var products = await ProductsRepository<Product>.GetItemsAsync(p => p.ProductID == productID);
    
        // Display the details of the product
        return View(products.First());
    }
    ```

6.  Add a view to the **View/Products** folder. Name the view **GetProductDetails**. Select the template **Empty (without model)**. Select **Use a layout page**, and specify the page **\~/Views/Shared/\_Layout.cshtml**.

7.  Modify the Razor code in the view; specify **Adventure\_Works.Models.Product** as the model, and change the title and page heading as shown below:

    ```HTML 
    @model Adventure_Works.Models.Product
    
    @{
        ViewBag.Title = "Products";
        Layout = "~/Views/Shared/_Layout.cshtml";
    }
    
    <h1>Product Details</h1>
    ```

8.  Add the following HTML markup below the page heading:

    ```HTML 
    <div class="panel panel-default">
        <div class="panel panel-body">
            <div class="form-group">
                <table class="table">
                    <tr>
                        <td>Product Number: </td>
                        <td>@Html.DisplayTextFor(p => p.ProductNumber)</td>
                    </tr>
                    <tr>
                        <td>Product Name: </td>
                        <td>@Html.DisplayTextFor(p => p.ProductName)</td>
                    </tr>
                    <tr>
                        <td>Model: </td>
                        <td>@Html.DisplayTextFor(p => p.Model)</td>
                    </tr>
                    <tr>
                        <td>Description: </td>
                        <td>@Html.DisplayTextFor(p => p.Description)</td>
                    </tr>
                    <tr>
                        <td>Price: </td>
                        @if (Model.ListPrice == 0)
                        {
                            <td><p>Contact Adventure-Works for price information</p></td>
                        }
                        else
                        {
                            <td>@Html.DisplayTextFor(p => p.ListPrice)</td>
                        }
                    </tr>
                    <tr>
                        <td>Color: </td>
                        <td>@Html.DisplayTextFor(p => p.Color)</td>
                    </tr>
                    <tr>
                        <td>Size: </td>
                        <td>@Html.DisplayTextFor(p => p.Size)</td>
                    </tr>
                    <tr>
                        <td>Weight: </td>
                        <td>@Html.DisplayTextFor(p => p.Weight)</td>
                    </tr>
                    <tr>
                        <td>In Stock: </td>
                        <td>@Html.DisplayTextFor(p => p.QuantityInStock)</td>
                    </tr>
                    @if (Model.Documentation.Document.Length > 0)
                    {
                        <tr>
                            <td>Documents: </td>
                            <td>
                                @Html.DisplayTextFor(p => p.Documentation)
                                <a href="@Model.Documentation.Document">Click to download</a>
                            </td>
                        </tr>
                    }
                    <tr>
                        <td>Image: </td>
                        <td>
                            <img src="@Model.Images.LargePhoto" />
                        </td>
                    </tr>
                </table>
            </div>
        </div>
    </div>
    ```
    
    This code displays the details of the product in a tabular layout. Note that the link for product documentation is specified as an anchor (the user can click this link to download the documentation), and the image is displayed using an **\<img>** tag. In both cases, the data is downloaded from blob storage.

9.  Build and run the web app. It should function as before, but now you should be able to click the **Details** link for a product to view the data for that product.

10. Close the web app.

**Result**: At the end of this exercise, you should have created an application that you can use to query product information.

## Exercise 4: Maintaining Stock Levels in the Product Catalog

### Exercise 4 Scenario

You will extend the web app to enable customers to buy items. The data for each product includes the number in stock, and this value should be updated as purchases occur. As is common in many online retail systems, the stock level displayed could become out of date while the customer is browsing products. If there is insufficient stock available when the customer commits to buying an item, it will be placed on back order instead and the customer notified. This will involve creating a new **backorder** document and saving it in a collection in Cosmos DB for a separate back-orders system to process.

> **Note**: The back-orders processing system is not implemented in this lab.

The main tasks for this exercise are as follows:

1.  Create a collection and repository for storing back orders.

2.  Extend the repository class to enable document creation and update.

3.  Add **buy** functionality to the product details view.

4.  Close down the lab.

### Task 1: Create a Collection and Repository for Storing Back Orders

1.  Using the Azure portal, add a new collection named **BackOrders** to the **SalesData** database in your Cosmos DB account. Partition the data by **productid**, and set the throughput to **1000** RU/s.

2.  Using Visual Studio, open the **Adventure-Works** solution in the **E:\\Labfiles\\Lab02\\Starter\\Adventure-Works-Ex4** folder. This is a copy of the completed web app from exercise 3.

3.  Edit the **Web.config** file, and add the following setting to the list of app settings:

    ```XML 
    <appSettings>
    ...
    <add key="BackOrderCollection" value="BackOrders"/>
    ...
    </appSettings>
    ```

4.  Edit the **Product.cs** file in the **Models** folder, and add the **ProductBackOrder** class shown below to this file. This class represents the document structure for a back order:

    ```csharp 
    public class ProductBackOrder
    {
        [JsonProperty("id")]
        public string BackOrderID { get; set; }
    
        [JsonProperty("productid")]
        public string ProductID { get; set; }
    
        [JsonProperty("productname")]
        public string ProductName { get; set; }
    
        [JsonProperty("productnumber")]
        public string ProductNumber { get; set; }
    
        [JsonProperty("numberonbackorder")]
        public int NumberOnBackOrder { get; set; }
    
        [JsonProperty("backorderdate")]
        public DateTime BackOrderDate { get; set; } 
    }
    ```

5.  Open the **global.asax** file, and add the following statement to the end of the **Application_Start** method, to create a repository for handling **ProductBackOrder** documents:

    ```csharp 
    protected void Application_Start()
    {
        ...
        ...
        ProductsRepository<Adventure_Works.Models.ProductBackOrder>.Initialize(ConfigurationManager.AppSettings["BackOrderCollection"]);
    }
    ```

### Task 2: Extend the Repository Class to Enable Document Creation and Update

1.  Edit the **ProductsRepository.cs** file, and add the following **using** directives to the list at the top of the file:

    ```csharp 
    using System.Net;
    using Microsoft.Azure.Documents;
    ```

2.  Add the **CreateItem** method shown below to the end of the **ProductsRepository\<T>** class. This method uses the SQL API to add the document represented by the **item** parameter to the collection. It returns a Boolean value indicating whether the create operation was successful:

    ```csharp 
    public static async Task<bool> CreateItem(T item)
    {
        // Add the new document to the collection
        Uri collectionUri = UriFactory.CreateDocumentCollectionUri(database, collection);
        var response = await client.CreateDocumentAsync(collectionUri, item);
    
        // Examine the status of the response, to determine whether the document was created successfully or not
        return response.StatusCode == HttpStatusCode.Created;
    }
    ```

3.  Add the **IncrementNumericValueInDocument** method shown below to the **ProductsRepository\<T>** class:

    ```csharp 
    public static async Task<int> IncrementNumericValueInDocumentAsync(string docID, string property, int value, string partitionKey = null)
    {
        // TODO: Fetch the doc to be updated
    
        // TODO: Change the value of the specified property
    
        // TODO: Attempt to write the modified document back to the database
        // If another user modifies the same doc at the same time, this code will throw an exception back to the caller where it should be handled
    
        // TODO: Return the new value of the property that was updated
    }
    ```
    
    The purpose of this method is to increment the numeric field specified by the **property** parameter in a document identified by the **docID** parameter by the amount specified in the **value** parameter. The optional **partionKey** parameter is used to locate the partition in which the document resides (this parameter is required if a collection is partitioned).

4.  Replace the comment **TODO: Fetch the doc to be updated** with the following block of code. These statements ensure that the most recent version of the product document is retrieved; the document might have been updated while the customer was browsing:

    ```csharp 
    Uri docUri = UriFactory.CreateDocumentUri(database, collection, docID);
    var options = partitionKey == null ? null : new RequestOptions
    {
        PartitionKey = new PartitionKey(partitionKey)
    };
    
    var response = await client.ReadDocumentAsync(docUri, options);
    var doc = response.Resource;
    ```

5.  Replace the comment **TODO: Change the value of the specified property** with these statements. This code uses the generic **GetPropertyValue** method of the SQL API to read the value of the named property from the document. The **SetPropertyValue** method overwrites the value of the property in the document:

    ```csharp 
    var propVal = doc.GetPropertyValue<int>(property);
    propVal += value;
    doc.SetPropertyValue(property, propVal);
    ```

6.  Replace the comment **TODO: Attempt to write the modified document back to the database** with the following code.

    ```csharp 
    options = new RequestOptions
    {
        AccessCondition = new AccessCondition
        {
            Condition = doc.ETag,
            Type = AccessConditionType.IfMatch
        }
    };
    response = await client.ReplaceDocumentAsync(doc.SelfLink, doc, options);
    ```
    
    There is a chance that another user could have updated the same document at the same time. This code uses the **ETag** property of the document to check for concurrent update, and throws an exception if the document has been modified. The client application calling this method should be prepared to handle the exception; for example, it could re-query the database and display the latest version of the data, and then enable the user to repeat the operation if necessary:

7.  Replace the comment **TODO: Return the new value of the property that was updated** with the following statement:

    ```csharp 
    return propVal;
    ```

### Task 3: Add Buy Functionality to the Product Details View

1.  In the **GetProductDetails.cshtml** file in the **View/Products** folder, add the following HTML markup immediately after the closing **\</table>** tag:

    ```HTML 
    @using (Html.BeginForm("BuyProduct", "Products", FormMethod.Post, new { role = "form" }))
    {
        <div class="form-group">
            <p>Number Required: 
            <input name="productID" type="hidden" value="@Model.ProductID" />
            <input name="subcategory" type="hidden" value="@Model.ProductCategory.Subcategory" />
            <input name="productName" type="hidden" value="@Model.ProductName" />
            <input name="productNumber" type="hidden" value="@Model.ProductNumber" />
            <input id="numRequired" name="numRequired" class="form-control" type="number" value="1" min="1"/></p>
            <p>
                <button type="submit" class="btn btn-primary">Purchase</button>
            </p>
        </div>
    }
    ```
    
    This markup creates an HTML form that enables the user to enter the number of items required. The **Purchase** button triggers the **BuyProduct** method in the **ProductsController** (you will write this method shortly). The parameters passed to the **BuyProduct** method consist of the value in the **numRequired** field, together with the contents of the hidden fields containing the product id, category, subcategory, and number.

2.  Add the following style after the last closing **\</div>** tag in the file. This style sets the display width of the **numRequired** field on the form:

    ```CSS 
    <style>
        #numRequired {
            width: 6em;
        }
    </style>
    ```

3.  Open the **ProductsController.cs** file in the **Controllers** folder. Add the following method named **BuyProductAsync** to the **ProductsController** class:

    ```csharp 
    // Method called when the user wishes to purchase a product
    [ActionName("BuyProduct")]
    [HttpPost]
    public async Task<ActionResult> BuyProductAsync(string productID, string subcategory, string productName, string productNumber, int numRequired)
    {
        // Use the repository to update the database and return the new stock level
        int newStockLevel = await ProductsRepository<Product>.IncrementNumericValueInDocumentAsync(productID, "quantityinstock", -numRequired, subcategory);
    
        // If the new stock level is now negative, undo the update and place a back order instead (Adventure-Works currently doesn't allow split orders)
        if (newStockLevel < 0)
        {
            await ProductsRepository<Product>.IncrementNumericValueInDocumentAsync(productID, "quantityinstock", numRequired, subcategory);
            var backOrder = new ProductBackOrder
            {
                BackOrderID = Guid.NewGuid().ToString(),
                ProductID = productID,
                ProductName = productName,
                ProductNumber = productNumber,
                NumberOnBackOrder = numRequired,
                BackOrderDate = DateTime.UtcNow
            };
    
            await ProductsRepository<ProductBackOrder>.CreateItem(backOrder);
        }
        return View(newStockLevel);
    }
    ```
    
    This method runs when the customer clicks **Purchase**. It uses the products repository to update the stock level (this is a decrement operation rather than increment, so the amount specified is converted to a negative value). If the quantity left in stock as a result of this operation is negative, then there is insufficient available to satisfy the order. In this case, the stock level is reinstated and a back order placed instead (the web application does not currently support orders split across multiple deliveries). The results of the request are displayed using another view.

4.  Add another view to the **Views/Products** folder. Name the view **BuyProduct**. Select the template **Empty (without model)**. Select **Use a layout page**, and specify the page **\~/Views/Shared/\_Layout.cshtml**.

5.  Replace the markup in the view with the following code. In this view, the **model** data consists of the new stock level. If this value is negative there was insufficient stock available so the message **Backorder created** appears, otherwise the message **Order placed** is displayed:

    ```HTML 
    @model int
    
    @{
        ViewBag.Title = "Products";
        Layout = "~/Views/Shared/_Layout.cshtml";
    }
    
    <h1>Product Details</h1>
    <div class="panel panel-default">
        <div class="panel panel-body">
            @if (Model < 0)
            {
                <p>Backorder created</p>
            } else
            {
                <p>Order placed</p>
            }
        </div>
    </div>
    ```

6.  Build and run the application. Display the details for a product and make a purchase. Verify that the **Order placed** message appears. View the product again, and verify that the number in stock has changed.

7.  Attempt to buy 5000 of the same product. This time the message **Backorder created** should be displayed. View the product again, and verify that the number in stock hasn't changed this time, then close the web app.

8.  Use the Azure Portal Data Explorer to examine the **BackOrders** collection in the **SalesData** database. Verify that a document has been added that specifies a backorder of 5000 of the product you selected.

### Task 4: Lab close down

  - To reduce your costs delete the **20777\_Mod02** resource group containing your Cosmos DB database and storage account.

**Result**: In this lab, you have used what you have learned in this lesson to design a document schema, load data into a collection, and to query, modify, and delete documents in a collection.

---
© 2018 Microsoft Corporation. All rights reserved.

The text in this document is available under the [Creative Commons Attribution 3.0 License](https://creativecommons.org/licenses/by/3.0/legalcode), additional terms may apply. All other content contained in this document (including, without limitation, trademarks, logos, images, etc.) are **not** included within the Creative Commons license grant. This document does not provide you with any legal rights to any intellectual property in any Microsoft product. You may copy and use this document for your internal, reference purposes.

This document is provided "as-is." Information and views expressed in this document, including URL and other Internet Web site references, may change without notice. You bear the risk of using it. Some examples are for illustration only and are fictitious. No real association is intended or inferred. Microsoft makes no warranties, express or implied, with respect to the information provided here.
