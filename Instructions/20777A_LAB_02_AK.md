# Lab Answer Key: Module 2: Designing and Implementing SQL API Database Applications

- [Lab Answer Key: Module 2: Designing and Implementing SQL API Database Applications](#lab-answer-key-module-2-designing-and-implementing-sql-api-database-applications)
  - [Lab: Designing and Implementing a Document Database](#lab-designing-and-implementing-a-document-database)
    - [Exercise 1: Design the Document Structure for the Product Catalog](#exercise-1-design-the-document-structure-for-the-product-catalog)
      - [Task 1: Prepare the Environment](#task-1-prepare-the-environment)
      - [Task 2: Analyze the requirements](#task-2-analyze-the-requirements)
      - [Task 3: Design the Documents and Partitioning Strategy](#task-3-design-the-documents-and-partitioning-strategy)
      - [Task 4: Create a Document Database Using the Cosmos DB SQL API](#task-4-create-a-document-database-using-the-cosmos-db-sql-api)
    - [Exercise 2: Import Data into the SalesData Database](#exercise-2-import-data-into-the-salesdata-database)
      - [Task 1: Import Category and Subcategory Data into the Cosmos DB Database](#task-1-import-category-and-subcategory-data-into-the-cosmos-db-database)
      - [Task 2: Import Product Data into the Cosmos DB Database](#task-2-import-product-data-into-the-cosmos-db-database)
    - [Exercise 3: Querying Product Catalog Information](#exercise-3-querying-product-catalog-information)
      - [Task 1: Create the Adventure-Works Web Application](#task-1-create-the-adventure-works-web-application)
      - [Task 2: Define the Models and ViewModels for the Web Application](#task-2-define-the-models-and-viewmodels-for-the-web-application)
      - [Task 3: Implement a Repository Class that Connects to the Cosmos DB Database](#task-3-implement-a-repository-class-that-connects-to-the-cosmos-db-database)
      - [Task 4: Create the Products Controller and Initial View](#task-4-create-the-products-controller-and-initial-view)
      - [Task 5: Extend the Products Controller to Fetch and Display Product Data](#task-5-extend-the-products-controller-to-fetch-and-display-product-data)
    - [Exercise 4: Maintaining Stock Levels in the Product Catalog](#exercise-4-maintaining-stock-levels-in-the-product-catalog)
      - [Task 1: Create a Collection and Repository for Storing Back Orders](#task-1-create-a-collection-and-repository-for-storing-back-orders)
      - [Task 2: Extend the Repository Class to Enable Document Creation and Update](#task-2-extend-the-repository-class-to-enable-document-creation-and-update)
      - [Task 3: Add Buy Functionality to the Product Details View](#task-3-add-buy-functionality-to-the-product-details-view)
      - [Task 4: Lab Close Down](#task-4-lab-close-down)
## Lab: Designing and Implementing a Document Database

### Exercise 1: Design the Document Structure for the Product Catalog

#### Task 1: Prepare the Environment

1.  Ensure that the **MT17B-WS2016-NAT** and **20777A-LON-DEV** virtual machines are running, and then log on to **20777A-LON-DEV** as **Administrator** with the password **Pa55w.rd**.

2.  On the Windows toolbar, click **File Explorer**.

3.  In File Explorer, navigate to **E:\\Labfiles\\Lab02\\Starter**, right-click **Setup.cmd**, and then click **Run as administrator**.

4.  Wait for the script to finish.

5.  On the Windows toolbar, click **Internet Explorer**.

6.  In Internet Explorer, go to **http://portal.azure.com**, and sign in using the Microsoft account that is associated with your Azure Learning Pass subscription.

7.  In the Azure Portal, click **+ Create a resource**.

8.  On the **New** blade, in the search box, type **storage account**, and then press Enter.

9.  On the **Everything** blade, click **Storage account - blob, file, table, queue**.

10. On the **Storage account - blob, file, table, queue** blade, click **Create**.

11. On the **Create storage account** blade, under the **Resource group** box, click **Create new**, type **20777\_Mod02**, and then click **OK**.

12. In the **Storage account name** box, type **20777blob\<*your name\>\<the day*\>**, for example, **20777blobjohn31**.

13. In the **Location** drop-down list, click the region closest to your current location.

14. In the **Account kind** list, click **BlobStorage**.

15. In the **Replication** list, click **Locally-redundant storage (LRS)**.

16. Click **Review + create**, and then click **Create**. 

17. In the Azure Portal, click **All resources**, and then click **20777blob\<*your name\>\<the day*\>**.

18. On the **20777blob\<*your name\>\<the day*\>** blade, under **Blob Service**, click **Blobs**.

19. On the **Blobs** blade, click **+ Container**.

20. In the **New container** dialog box, in the **Name** box, type **20777-mod2-blobs**.

21. In the **Public access level** drop-down list, click **Blob (anonymous read access for blobs only)**, and then click **OK**.

22. On the **20777blob\<*your name\>\<the day*\>** blade, under **Settings**, click **Access keys**.

23. Under **key1**, make a note of the **Connection string** value.

24. In the left pane of the Azure portal, click **+ Create a resource**.

25. On the **New** blade, in the search box, type **Cosmos DB**, and then press Enter.

26. On the **Everything** blade, click **Azure Cosmos DB**, and then click **Create**.

27. On the **Create Azure Cosmos DB Account** blade, in the **Resource Group** drop-down list, click **20777\_Mod02**. 

28. In the **Account name** box, type **20777-sql-\<*your name\>-\<the day*\>**, for example, **20777-sql-john-31**.

29. In the **API** drop-down list, click **Core (SQL)**.

30. In the **Location** drop-down list, click the region closest to your current location.

31. Click **Review + create**, and then click **Create**.

32. Wait for the Azure Cosmos DB to be createdâ€”this could take a few minutes.

33. In the Azure Portal, click **All resources**, and then click **20777-sql-\<*your name\>-\<the day*\>**.

34. On the **20777-sql-\<*your name\>-\<the day*\>** blade, click **Data Explorer**.

35. In the **SQL API** pane, click **New Database**.

36. On the **New Database** blade, in the **Database id** box, type **SalesData**, and then click **OK**.

37. On the **20777a-sql-\<*your name\>-\<the day*\>** blade, under **Settings**, click **Keys**.

38. Make a note of the **URI**, and **PRIMARY KEY** values.

#### Task 2: Analyze the requirements

There are no detailed steps for this task. Read the description for the task in **20777A\_LAB\_02.md**.

#### Task 3: Design the Documents and Partitioning Strategy

1.  On the Start menu, click **Visual Studio 2017**.

2.  In Visual Studio, on the **Tools** menu, click **Connect to Database**.

3.  In the **Choose Data Source** dialog box, click **Microsoft SQL Server Database File**, and then click **Continue**.

4.  In the **Add Connection** dialog box, in the **Database file name (new or existing)** box, type **E:\\Labfiles\\Lab02\\Data\\AdventureWorks2016\_Data.mdf**, and then click **OK**.

5.  In Server Explorer, right-click **AdventureWorks2016\_Data.mdf**, and then click **New Query**.

6.  On the **SQLQuery1.sql** tab, type the following code:

    ```SQL
    SELECT c.Name AS category, s.Name AS subcategory
    FROM Production.ProductCategory c
    JOIN Production.ProductSubcategory s
    ON s.ProductCategoryID = c.ProductCategoryID
    ```

7.  On the **SQL** menu, click **Execute**, and then review the results of the query.

8.  In the **SQLQuery1.sql** tab, delete the existing query, and then type the following code:

    ```SQL
    SELECT p.ProductID, p.Name, p.ProductNumber, p.Color, p.ListPrice, p.Size, pum.Name As SizeUnit,
        p.Weight, pw.Name As WeightUnit, psc.Name As SubcategoryName, pc.Name As CategoryName, i.Quantity,
        d.Title, d.DocumentSummary, d.Document, d.FileName AS DocumentFileName, pm.Name AS ModelName,ill.Diagram,
        ph.ThumbnailPhoto, ph.ThumbnailPhotoFileName, ph.LargePhoto, ph.LargePhotoFileName, pds.Description
    FROM Production.Product p
    LEFT JOIN Production.ProductSubcategory psc
    ON p.ProductSubCategoryID = psc.ProductSubcategoryID
    LEFT JOIN Production.ProductCategory pc
    ON psc.ProductCategoryID = pc.ProductCategoryID
    LEFT JOIN(SELECT ProductID, SUM(Quantity) AS Quantity FROM Production.ProductInventory GROUP BY ProductID) AS i
    ON p.ProductID = i.ProductID
    LEFT JOIN Production.UnitMeasure pum
    ON p.SizeUnitMeasureCode = pum.UnitMeasureCode
    LEFT JOIN Production.UnitMeasure pw
    ON p.WeightUnitMeasureCode = pw.UnitMeasureCode
    LEFT JOIN  Production.ProductDocument pd
    ON p.ProductID = pd.ProductID
    LEFT JOIN Production.Document d
    ON pd.DocumentNode = d.DocumentNode
    LEFT JOIN Production.ProductModel pm
    ON p.ProductModelID = pm.ProductModelID
    LEFT JOIN Production.ProductModelIllustration pmi
    ON pm.ProductModelID = pmi.ProductModelID
    LEFT JOIN Production.Illustration ill
    ON pmi.IllustrationID = ill.IllustrationID
    LEFT JOIN Production.ProductProductPhoto ppp
    ON P.ProductID = ppp.ProductID
    LEFT JOIN Production.ProductPhoto ph
    ON ppp.ProductPhotoID = ph.ProductPhotoID
    LEFT JOIN Production.ProductModelProductDescriptionCulture pmdc
    ON pm.ProductModelID = pmdc.ProductModelID AND pmdc.CultureID = 'en'
    LEFT JOIN Production.ProductDescription pds
    ON pmdc.ProductDescriptionID = pds.ProductDescriptionID
    ```

9.  On the **SQL** menu, click **Execute**, and then review the results of the query.

    **Question**: What different approaches to the document design did you consider; what are their advantages and disadvantages?
    
    **Answer**: The answer will depend on students' experience. You could create a document for each category containing the subcategories as sub-documents, and products as sub-sub-documents within each subcategory. However, this is probably not the best approach as the number of products in each category/subcategory is unbounded. The result would be a small number of very large documents and a solution that doesn't scale well.
    
    An alternative approach is to create a document for each product, and store category/subcategory information as properties within each product. This solution scales better. But you also need to consider how applications will let a user select category and subcategory information for performing searches. For example, if the user wants to search for products by subcategory, it would be useful to be able to present the user with a list of subcategories from which to make a selection. If this data is duplicated across many product documents, generating a list of categories and subcategories could be time consuming.
    
    **Question**: Will you store all the documents in one collection, or use more than one collection?
    
    **Answer**: The answer will depend on students' experience. The most optimal solution is to create two collections; one for products and another for category/subcategory information. Products can either be linked to the appropriate category/subcategory document - this would enable category/subcategory information to be easily updated as it is only held in one place -, or the category/subcategory data can be copied to each document - this would result in faster queries as each time a document is retrieved you don't need to perform an additional retrieval of category/subcategory information. Given that categories and subcategories don't change very often, and that the system must support fast querying, the best solution is to copy the data into each product.
    
    **Question**: The product data includes binary information in the form of Word documents and image files. How will you accommodate these files in Cosmos DB?
    
    **Answer**: The answer will depend on students' experience. This data is best held either as attachments in the Cosmos DB database, or in separate blob storage (you don't necessarily want to download this information every time you query a product). There is a limit on the amount of data you can hold as attachments in a collection, and there could be a large number of images and other objects referenced by products in the catalog, so the preferred solution is to store this data in Azure blob storage and add a URL that references the appropriate data to each product document.
    
    The products collection could have the following structure:
    
	```JSON
        {
            "id": "977",
            "productname": "Road-750 Black, 58",
            "productnumber": "BK-R19B-58",
            "color": "Black",
            "listprice": 539.99,
            "size": "58 Centimeter",
            "weight": "20.79 US pound",
            "quantityinstock": 153,
            "model": "Road-750",
            "description": "Entry level adult bike; offers a comfortable ride cross-country or down the block. Quick-release hubs and rims.",
            "productcategory": {
                "subcategory": "Road Bikes",
                "category": "Bikes"
            },
            "documentation": {
                "documenttitle": "Introduction 1",
                "documentsummary": "",
                "document": "<link to blob storage>"
            },
            "images": {
                "diagram": "",
                "thumbnail": "<link to blob storage>",
                "largephoto": "<link to blob storage>"
            }
        }
	```
    Documents in the category/subcategory collection could look like this. There is a document for each subcategory:
    
    ```JSON
        {
            "category": "Bikes",
            "subcategory": "Mountain Bikes",
        }
        
        {
            "category": "Bikes",
            "subcategory": "Road Bikes",
        }
    ```

10. Identify a partitioning strategy for the product data.

    **Question**: Assuming that the collection was going to scale to many millions of products, how would you partition the products collection?
    
    **Answer**: The answer will depend on students' experience. You could partition product data by **ProductNumber**, but this would lead to each product being stored in its own partition. Querying by category or subcategory would lead to many cross-partition queries, and this strategy would be very inefficient.
    
    Partitioning products by category would likely be too coarse a strategy as there are very few categories (4 currently)
    
    Partitioning products by subcategory will create more partitions to help distribute the load, while still reducing the likelihood of performing cross-partition queries.
    
    > **Note**: partitioning by subcategory could result in data skew (there is not an even distribution of products across subcategories, so some partitions will be bigger then others), is this a problem in this scenario? Probably not - the collection is query heavy (updates are far less frequent). Searches that locate products by subcategory will only need to scan a single partition. Using a different partition key could help to distribute updates more evenly, but would impact the response time of queries.
    
    **Question**: Will the product category/subcategory documents benefit from partitioning?
    
    **Answer**: The category/subcategory collection is very small and is unlikely to grow; it doesn't currently require partitioning. This strategy will also ensure that queries that generate a list of categories from the subcategory documents do not have to perform cross-partition searches.

#### Task 4: Create a Document Database Using the Cosmos DB SQL API

1.  In Internet Explorer, on the **20777-sql-\<*your name\>-\<the day*\>** blade, click **Data Explorer**.

2.  In the **SQL API** pane, right-click **SalesData**, and then click **New Collection**.

3.  On the **Add Collection** blade, in the **Collection Id** box, type **ProductCatalog**.

4.  In the **Partition key** box, type **/productcategory/subcategory**.

5.  In the **Throughput (400 - 1,000,000 RU/s)** box, type **1000**.

6.  Under **Unique keys**, click **+ Add unique key**.

7.  In the **Unique keys** box, type **/productnumber**, and then click **OK**.

8.  In the **SQL API** pane, right-click **SalesData**, and then click **New Collection**.

9.  On the **Add Collection** blade, in the **Collection Id** box, type **ProductCategories**.

10. In the **Partition key** box, type **/productcategory/subcategory**.

11. In the **Throughput (400 - 1,000,000 RU/s)** box, type **1000**.

12. Under **Unique keys**, click **+ Add unique key**.

13. In the **Unique keys** box, type **/subcategory**, and then click **OK**.

**Result**: At the end of this exercise, you should have created a database and collection to hold the product catalog, and designed the document schema.

### Exercise 2: Import Data into the SalesData Database

#### Task 1: Import Category and Subcategory Data into the Cosmos DB Database

1.  In Visual Studio, on the **SqlQuery1.sql** tab, delete the existing text, and then type the following code:

    ```SQL
    SELECT c.Name AS category, s.Name AS subcategory
    FROM Production.ProductCategory c
    JOIN Production.ProductSubcategory s
    ON s.ProductCategoryID = c.ProductCategoryID
    FOR json path
    ```

2.  On the **SQL** menu, click **Execute**.

3.  In the **Results** pane, click the first cell of the result (the text is underlined in blue). This opens a new tab (with a name that starts **JSON\_**) with the results of the query.

4.  On the **File** menu, click **Save JSON\_\<identifier\> As** (**\<identifier\>** will be a random value).

5.  In the **Save File As** dialog box, in the **File name** box, type **E:\\Labfiles\\Lab02\\categories.json**, and then click **Save**.

6.  In Internet Explorer, in the **SQL API** pane, expand **SalesData**, click **ProductCategories**, and then click **Upload**.

7.  On the **Upload Documents** blade, click browse (the folder icon).

8.  In the **Choose** **File to Upload** dialog box, in the **File name** box, type **E:\\Labfiles\\Lab02\\categories.json**, and then click **Open**.

9.  On the **Upload Documents** blade, click **Upload**.

10. Wait for the upload to complete; the result message will report that **38 documents created**.

11. In the **SQL API** pane, under **ProductCategories**, click **Documents**.

12. On the **Documents** tab, click a document to verify its contents.

#### Task 2: Import Product Data into the Cosmos DB Database

1.  In Visual Studio, on the **File** menu, point to **Open**, and then click **Project/Solution**.

2.  In the **Open Project** dialog box, in the **File name** box, type **E:\\Labfiles\\Lab02\\Starter\\MigrateProductData\\MigrateProductData.sln**, and then click **Open**.

3.  In the **Microsoft Visual Studio** dialog box, prompting to save changes, click **No**.

4.  In the **Security Warning for MigrateProductData** dialog box, clear the **Ask me for every project in this solution** check box, click **OK**.

5.  In Solution Explorer, double-click **App.config**.

6.  In App.config, in the **Value** attribute of the **EndpointUrl** key, paste the **URI** value you noted earlier, replacing the text \<**URL**\>.

7.  In the **Value** attribute of the **PrimaryKey** key, paste the **PRIMARY KEY** value you noted earlier, replacing the text **\<PRIMARY KEY\>**.

8.  In the **Value** attribute of the **BlobStorageConnectionString** key, paste the **Connection string** value you noted earlier, replacing the text **\<CONNECTION STRING\>**.

9.  In the **Value** attribute of the **BlobContainer** key, delete the text **\<BLOB CONTAINER NAME\>**, and then type **20777-mod2-blobs**.

10. In Solution Explorer, double-click **Product.cs**.

11. In Product.cs, under the comment **TODO: Specify fields for the Product document**, replace:

    ```csharp 
    internal class Product
    {
    
    }
    ```
    
    with:
    
    ```csharp
    internal class Product
    {
        [JsonProperty("id")]
        internal string ProductID { get; set; }
    
        [JsonProperty("productname")]
        internal string ProductName { get; set; }
    
        [JsonProperty("productnumber")]
        internal string ProductNumber { get; set; }
    
        [JsonProperty("color")]
        internal string Color { get; set; }
    
        [JsonProperty("listprice")]
        public decimal ListPrice { get; set; }
    
        [JsonProperty("size")]
        internal string Size { get; set; }
    
        [JsonProperty("weight")]
        internal string Weight { get; set; }
    
        [JsonProperty("quantityinstock")]
        internal int QuantityInStock { get; set; }
    
        [JsonProperty("model")]
        internal string Model { get; set; }
    
        [JsonProperty("description")]
        internal string Description { get; set; }
    
        [JsonProperty("productcategory")]
        internal ProductCategoryData ProductCategory { get; set; }
    
        [JsonProperty("documentation")]
        internal ProductDocumentData Documentation { get; set; }
    
        [JsonProperty("images")]
        internal ProductImageData Images { get; set; }
    }
    ```


12. Under the comment **TODO: Specify fields for the ProductCategoryData subdocument**, replace:

    ```csharp 
    internal class ProductCategoryData
    {
    
    }
    ```
    
    with:
    
    ```csharp
    internal class ProductCategoryData
    {
        [JsonProperty("subcategory")]
        internal string Subcategory { get; set; }
    
        [JsonProperty("category")]
        internal string Category { get; set; }
    }
    ```

13. Under the comment **TODO: Specify fields for the ProductDocumentData subdocument**, replace:

    ```csharp
    internal class ProductDocumentData
    {
    
    }
    ```
    
    with:
    
    ```csharp
    internal class ProductDocumentData
    {
        [JsonProperty("documenttitle")]
        internal string DocumentTitle { get; set; }
    
        [JsonProperty("documentsummary")]
        internal string DocumentSummary { get; set; }
    
        [JsonProperty("document")]
        internal string Document { get; set; }
    }
    ```

14. Under the comment **TODO: Specify fields for the ProductImageData subdocument**, replace:

    ```csharp 
    internal class ProductImageData
    {
    
    }
    ```
    
    with:

    ```csharp    
    internal class ProductImageData
    {
        [JsonProperty("diagram")]
        internal string Diagram { get; set;  }
    
        [JsonProperty("thumbnail")]
        internal string Thumbnail { get; set; }
    
        [JsonProperty("largephoto")]
        internal string LargePhoto { get; set; }
    }
    ```


15. In Solution Explorer, double-click **Program.cs**.

16. Under the comment **TODO: Create a client to connect to the Cosmos DB database**, type the following code:

    ```csharp 
    this.client = new DocumentClient(new Uri(endpointUrl), primaryKey);
    ```

17. Under the comment **TODO: Connect to Azure Blob Storage**, type the following code:

    ```csharp
    if (!CloudStorageAccount.TryParse(this.blobStorageConnectionString, out CloudStorageAccount storageAccount))
    {
        Console.WriteLine("Invalid storage connection string");
        return;
    }
    this.blobClient = storageAccount.CreateCloudBlobClient();
    ```

18. Under the comment **TODO: Create a document from the current row retrieved from SQL Server**, type the following code:

    ```csharp 
    var productDocument = new Product
    {
        ProductID = reader["ProductID"].ToString(),
        ProductName = reader["Name"].ToString(),
        ProductNumber = reader["ProductNumber"].ToString(),
        Color = reader["Color"].ToString(),
        ListPrice = Decimal.Parse(reader["ListPrice"].ToString()),
        Size = $"{reader["Size"].ToString()} {reader["SizeUnit"].ToString()}",
        Weight = $"{reader["Weight"].ToString()} {reader["WeightUnit"].ToString()}",
        QuantityInStock = Int32.Parse(reader["Quantity"].ToString() == "" ? "0" : reader["Quantity"].ToString()),
        Model = reader["ModelName"].ToString(),
        Description = reader["Description"].ToString(),
        ProductCategory = new ProductCategoryData
        {
            Subcategory = reader["SubcategoryName"].ToString(),
            Category = reader["CategoryName"].ToString(),
        },
        Documentation = new ProductDocumentData
        {
            DocumentTitle = reader["Title"].ToString(),
            DocumentSummary = reader["DocumentSummary"].ToString(),
            Document = await UploadDataToBlobStorageAsync(reader["Document"], reader["DocumentFileName"].ToString())
        },
        Images = new ProductImageData
        {
            Diagram = await UploadDataToBlobStorageAsync(reader["Diagram"], reader["ModelName"].ToString()),
            Thumbnail = await UploadDataToBlobStorageAsync(reader["ThumbnailPhoto"], reader["ThumbnailPhotoFileName"].ToString()),
            LargePhoto = await UploadDataToBlobStorageAsync(reader["LargePhoto"], reader["LargePhotoFileName"].ToString())
        }
    };
    ```

19. Under the comment **TODO: Upload the document to the collection in Cosmos DB**, type the following code:

    ```csharp 
    if (await UploadDocumentToCosmosDB(productDocument))
    {
        Console.WriteLine($"Added document {productDocument.ProductID} for {productDocument.ProductName}: {productDocument.Description}");
    }
    else
    {
        Console.WriteLine($"Upload failed for {productDocument.ProductID}: {productDocument.ProductName}");
    }
    ```

20. Under the comment **TODO: If the data is NULL, return an empty string**, type the following code:

    ```csharp 
    if (string.Compare(data.GetType().Name, "DBNull") == 0)
    {
        return string.Empty;
    }
    ```

21. Under the comment **TODO: Otherwise cast the data into a byte array**, type the following code:

    ```csharp 
    var byteData = data as byte[];
    ```

22. Under the comment **TODO: If the cast failed, the data probably contains a string, so use GetBytes to convert it into a byte array**, type:

    ```csharp
    if (byteData == null)
    {
        byteData = Encoding.ASCII.GetBytes(data.ToString());
    }
    ```

23. Under the comment **TODO: Get a reference to the blob container and a blob in Azure storage. The blob will hold the data being uploaded**, type the following code:

    ```csharp 
    var cloudBlobContainer = this.blobClient.GetContainerReference(this.blobContainer);
    var blockBlob = cloudBlobContainer.GetBlockBlobReference(name);
    ```

24. Under the comment **TODO: Upload the data to the blob**, type the following code:

    ```csharp 
    await blockBlob.UploadFromByteArrayAsync(byteData, 0, byteData.Length);
    ```

25. Under the comment **TODO: Return the URI of the new blob as a string**, type the following code:

    ```csharp 
    return blockBlob.Uri.ToString();
    ```

26. Under the comment **TODO: Add the document to the Cosmos DB database**, type the following code:

    ```csharp 
    Uri productCollection = UriFactory.CreateDocumentCollectionUri(this.database, this.collection);
    var response = await this.client.CreateDocumentAsync(productCollection, productDocument);
    return (response.StatusCode == System.Net.HttpStatusCode.Created);
    ```

27. Press F5 to build and run the application.

28. Verify that it retrieves the data from SQL Server and uploads the documents to Cosmos DB without reporting any errors.

29. In Internet Explorer, on the **20777-sql-\<*your name\>-\<the day*\>** blade, click **Data Explorer**.

30. In the **SQL API** pane, expand **SalesData**, expand **ProductCatalog**, and then click **Documents**.

31. Click on one of the documents in the list to view it.

32. Hold Ctrl and left click the value of the **/images/thumbnail** or **/images/largephoto** properties to view the associated images.

33. If the Internet Explorer message box appears, click **Options for this site**, and then click **Always allow**.

34. If the image does not appear in a new tab, repeat steps 30 to 32.

35. Close the No Image Available tab.

**Result**: At the end of this exercise, you should have populated your Cosmos DB database with product catalog information.

### Exercise 3: Querying Product Catalog Information

#### Task 1: Create the Adventure-Works Web Application

1.  In Visual Studio, on the **File** menu, point to **New**, and then click **Project**.

2.  In the **New Project** dialog box, expand **Visual C\#**, click **Web**, and then click **ASP.NET Web Application (.NET Framework)**.

3.  In the **Name** box, type **Adventure-Works**.

4.  In the **Location** box, type **E:\\Labfiles\\Lab02**, and then click **OK**.

5.  In the **New ASP.NET Web Application - Adventure-Works** dialog box, click **MVC**, and then click **OK**.

6.  On the **Tools** menu, point to **NuGet Package Manager**, and then click **Manage NuGet Packages for Solution**.

7.  On the **NuGet - Solution** tab, click **Browse**.

8.  In the **Search** box, type **Microsoft.Azure.DocumentDB**, and then click **Microsoft.Azure.DocumentDB**.

9.  In the right-hand pane, select the **Adventure-Works** check box, and then click **Install**.

10. In the **Preview Changes** dialog box, click **OK**.

11. In the **License Acceptance** dialog box, click **I Accept**.

12. On the **NuGet - Solution** tab, click **Updates**, and then clear the search box.

13. Select the **Select all packages** check box, and then click **Update**.

14. In the **Preview Changes** dialog box, click **OK**.

15. In the **License Acceptance** dialog box, click **I Accept**.

16. If a **Restart Visual Studio to finish the process** message appears, click **Restart**.

#### Task 2: Define the Models and ViewModels for the Web Application

1.  In Solution Explorer, right-click **Models**, point to **Add**, and then click **Class**.

2.  In the **Add New Item - Adventure-Works** dialog box, in the **Name** box, type **Product.cs**, and then click **Add**.

3.  In Product.cs, replace:

    ```csharp 
    public class Product
    {
    }
    ```
    
    with:
    
    ```csharp
    public class ProductCategoryData
    {
        [JsonProperty("subcategory")]
        public string Subcategory { get; set; }
    
        [JsonProperty("category")]
        public string Category { get; set; }
    }
    
    public class ProductDocumentData
    {
        [JsonProperty("documenttitle")]
        public string DocumentTitle { get; set; }
    
        [JsonProperty("documentsummary")]
        public string DocumentSummary { get; set; }
    
        [JsonProperty("document")]
        public string Document { get; set; }
    }
    
    public class ProductImageData
    {
        [JsonProperty("diagram")]
        public string Diagram { get; set; }
    
        [JsonProperty("thumbnail")]
        public string Thumbnail { get; set; }
    
        [JsonProperty("largephoto")]
        public string LargePhoto { get; set; }
    }
    
    public class Product
    {
        [JsonProperty("id")]
        public string ProductID { get; set; }
    
        [JsonProperty("productname")]
        public string ProductName { get; set; }
    
        [JsonProperty("productnumber")]
        public string ProductNumber { get; set; }
    
        [JsonProperty("color")]
        public string Color { get; set; }
    
        [JsonProperty("listprice")]
        public decimal ListPrice { get; set; }
    
        [JsonProperty("size")]
        public string Size { get; set; }
    
        [JsonProperty("weight")]
        public string Weight { get; set; }
    
        [JsonProperty("quantityinstock")]
        public int QuantityInStock { get; set; }
    
        [JsonProperty("model")]
        public string Model { get; set; }
    
        [JsonProperty("description")]
        public string Description { get; set; }
    
        [JsonProperty("productcategory")]
        public ProductCategoryData ProductCategory { get; set; }
    
        [JsonProperty("documentation")]
        public ProductDocumentData Documentation { get; set; }
    
        [JsonProperty("images")]
        public ProductImageData Images { get; set; }
    }
    ```

4.  At the beginning of the file, type the following code:

    ```csharp 
    using Newtonsoft.Json;
    ```

5.  In Solution Explorer, right-click **Models**, point to **Add**, and then click **Class**.

6.  In the **Add New Item - Adventure-Works** dialog box, in the **Name** box, type **ViewModels.cs**, and then click **Add**.

7.  In ViewModels.cs, replace:

    ```csharp 
    public class ViewModels
    {
    }
    ```
    
    with:
    
    ```csharp
    public class ProductCategoryViewModel
    {
        public string CategoryName { get; set; }
        public IEnumerable<SelectListItem> Categories { get; set; }
    }
    
    public class ProductSubcategoryViewModel
    {
        public string SubcategoryName { get; set; }
        public IEnumerable<SelectListItem> Subcategories { get; set; }
    }
    
    public class ProductViewModel
    {
        public string SearchString { get; set; }
        public IEnumerable<Product> Products { get; set; }
        public ProductCategoryViewModel SelectableCategories { get; set; }
        public ProductSubcategoryViewModel SelectableSubcategories { get; set; }
    }
    ```

8.  At the beginning of the file, type the following code:

    ```csharp 
    using System.Web.Mvc;
    ```

#### Task 3: Implement a Repository Class that Connects to the Cosmos DB Database

1.  In Solution Explorer, right-click **Adventure-Works** (not **Solution 'Adventure-Works'**), point to **Add**, and then click **Class**.

2.  In the **Add New Item - Adventure-Works** dialog box, in the **Name** box, type **ProductsRepository.cs**, and then click **Add**.

3.  In ProductsRepository.cs, replace:

    ```csharp 
    public class ProductsRepository
    {
    }
    ```
    
    with:

    ```csharp
    public static class ProductsRepository<T>
    {

    }
    ```

4.  At the beginning of the file, type the following code:

    ```csharp 
    using Microsoft.Azure.Documents.Client;
    using Microsoft.Azure.Documents.Linq;
    using System.Configuration;
    using System.Linq.Expressions;
    using System.Threading.Tasks;
    ```

5.  Inside the class definition:

    ```csharp 
    public static class ProductsRepository<T>
    {
    ```
    
    type:
    
    ```csharp    
        private static string endpointUrl;
        private static string primaryKey;
        private static string database;
        private static string collection;
        private static DocumentClient client;
    ```

6.  Type the following code:

    ```csharp 
    public static void Initialize(string coll)
    {
        endpointUrl = ConfigurationManager.AppSettings["EndpointUrl"];
        primaryKey = ConfigurationManager.AppSettings["PrimaryKey"];
        database = ConfigurationManager.AppSettings["Database"];
        collection = coll;
        client = new DocumentClient(new Uri(endpointUrl), primaryKey);
    }
    ```

7.  Type the following code:

    ```csharp 
    public static async Task<IEnumerable<T>> GetAllItemsAsync()
    {
        // Find all documents in the collection
        IDocumentQuery<T> query = client.CreateDocumentQuery<T>(
            UriFactory.CreateDocumentCollectionUri(database, collection))
            .AsDocumentQuery();
    
        // Return the documents as a list
        List<T> results = new List<T>();
        while (query.HasMoreResults)
        {
            results.AddRange(await query.ExecuteNextAsync<T>());
        }
    
        return results;
    }
    ```

8.  Type the following code:

    ```csharp 
    public static async Task<IEnumerable<T>> GetItemsAsync(Expression<Func<T, bool>> predicate)
    {
        // Find all documents in the collection that match the predicate
        IDocumentQuery<T> query = client.CreateDocumentQuery<T>(
            UriFactory.CreateDocumentCollectionUri(database, collection),
            new FeedOptions { EnableCrossPartitionQuery = true })
            .Where(predicate)
            .AsDocumentQuery();
    
        // Return the matching documents as a list
        List<T> results = new List<T>();
        while (query.HasMoreResults)
        {
            results.AddRange(await query.ExecuteNextAsync<T>());
        }
    
        return results;
    }
    ```

9.  In Solution Explorer, double-click **Web.config**.

10. In Web.config, add the following keys to the **appSettings** section:

    ```XML 
    <add key="EndpointUrl" value="~URL~" />
    <add key="PrimaryKey" value="~PRIMARY KEY~" />
    <add key="Database" value="SalesData" />
    <add key="ProductsCollection" value="ProductCatalog" />
    <add key="CategoriesCollection" value="ProductCategories" />
    ```

    The finished section should look like:

    ```XML 
    <configuration>
        <appSettings>
            <add key="EndpointUrl" value="~URL~" />
            <add key="PrimaryKey" value="~PRIMARY KEY~" />
            <add key="Database" value="SalesData" />
            <add key="ProductsCollection" value="ProductCatalog" />
            <add key="CategoriesCollection" value="ProductCategories" />
            <add key="webpages:Version" value="3.0.0.0" />
            <add key="webpages:Enabled" value="false" />
            ...
        </appSettings>
    ...
    ...
    </configuration>
    ```


11. In Web.config, in the value of the **EndpointUrl** key, paste the **URI** value you noted earlier, replacing the text **\~URL\~**.

12. In Web.config, in the value of the **PrimaryKey** key, paste the **PRIMARY KEY** value you noted earlier, replacing the text **\~PRIMARY KEY\~**.

13. In Solution Explorer, double-click **Global.asax**.

14. In Global.asax.cs, at the end of the **Application\_Start** method, type the following code:

    ```csharp 
    ProductsRepository<Adventure_Works.Models.Product>.Initialize(ConfigurationManager.AppSettings["ProductsCollection"]);
    ProductsRepository<Adventure_Works.Models.ProductCategoryData>.Initialize(ConfigurationManager.AppSettings["CategoriesCollection"]);
    ```
    
    The finished method should look like:
    
    ```csharp    
        protected void Application_Start()
        {
            ...
            ProductsRepository<Adventure_Works.Models.Product>.Initialize(ConfigurationManager.AppSettings["ProductsCollection"]);
            ProductsRepository<Adventure_Works.Models.ProductCategoryData>.Initialize(ConfigurationManager.AppSettings["CategoriesCollection"]);
        }
    ```

15. At the beginning of the file, type the following code:

    ```csharp 
    using System.Configuration;
    ```

#### Task 4: Create the Products Controller and Initial View

1.  In Solution Explorer, right-click **Controllers**, point to **Add**, and then click **Controller**.

2.  In the **Add Scaffold** dialog box, click **MVC 5 Controller - Empty**, and then click **Add**.

3.  In the **Add Controller** dialog box, in the **Controller name** box, type **ProductsController**, and then click **Add**.

4.  In ProductsController.cs, at the beginning of the file, type the following code:

    ```csharp 
    using Adventure_Works.Models;
    using System.Threading.Tasks;
    ```

5.  In the **ProductsController** class, after the **Index** method, type the following code:

    ```csharp 
    private async Task<IEnumerable<ProductCategoryData>> InitializeCategoryDataAsync()
    {
        // Retrieve the list of categories and subcategories from the document database
        var categoryData = await ProductsRepository<ProductCategoryData>.GetAllItemsAsync();
        Session["categoryData"] = categoryData;
        return categoryData;
    }
    ```

6.  Type the following code:

    ```csharp 
    private async Task<ProductCategoryViewModel> InitializeCategoriesAsync()
    {
        // Construct the ProductCategoryViewModel data using the data retrieved from the document database 
        var categoryData = Session["categoryData"] as IEnumerable<ProductCategoryData> ?? await ProductsRepository<ProductCategoryData>.GetAllItemsAsync();
        var distinctCategories = (from c in categoryData select c.Category).Distinct();
        var selectableCategories = new ProductCategoryViewModel { Categories = from c in distinctCategories select new SelectListItem { Text = c, Value = c } };
        Session["selectableCategories"] = selectableCategories;
        return selectableCategories;
    }
    ```

7.  Type the following code:

    ```csharp 
    private async Task<ProductSubcategoryViewModel> InitializeSubCategoriesAsync()
    {
        // Construct the ProductSubcategoryViewModel data using the data retrieved from the document database
        var categoryData = Session["categoryData"] as IEnumerable<ProductCategoryData> ?? await ProductsRepository<ProductCategoryData>.GetAllItemsAsync();
        var subcategoryData = (from c in categoryData select c.Subcategory);
        var selectableSubcategories = new ProductSubcategoryViewModel { Subcategories = from s in subcategoryData select new SelectListItem { Text = s, Value = s } };
        Session["selectableSubcategories"] = selectableSubcategories;
        return selectableSubcategories;
    }
    ```

8.  Type the following code:

    ```csharp 
    // Initial, default action for the form
    [ActionName("FindProducts")]
    [HttpGet]
    public async Task<ActionResult> FindProductsAsync()
    {
        // Build and display an initial view model containing just the list of categories and subcategories (don't display all products by default as there could be a lot of them)
        return View(new ProductViewModel
        {
            Products = new List<Product>(),
            SelectableCategories = Session["selectableCategories"] as ProductCategoryViewModel ?? await InitializeCategoriesAsync(),
            SelectableSubcategories = Session["selectableSubcategories"] as ProductSubcategoryViewModel ?? await InitializeSubCategoriesAsync()
        });
    }
    ```

9.  Delete the **Index** method from the **ProductsController** class:

    ```csharp 
    // GET: Products
    public ActionResult Index()
    {
        return View();
    }
    ```

10. In Solution Explorer, expand **Views**, right-click **Products**, point to **Add**, and then click **View**.

11. In the **Add View** dialog box, in the **View name** box, type **FindProducts**.

12. In the **Template** drop-down list, click **Empty (without model)**, and then ensure that **Use a layout page** is selected.

13. In the **Use a layout page** box, type **\~/Views/Shared/\_Layout.cshtml**, and then click **Add**.

14. In FindProducts.cshtml, at the beginning of the file, type the following code:

    ```HTML 
    @model Adventure_Works.Models.ProductViewModel
    ```

15. Replace:

    ```HTML 
    <h2>FindProducts</h2>
    ```
    
    with:
    
    ```HTML
    <h1>Product Catalog</h1>
    <div class="panel panel-default">
        <div class="panel panel-body">
    
            @using (Html.BeginForm("FindProducts", "Products", FormMethod.Post, new { role = "form" }))
            {
                <div class="form-group">
                    <h2>Categories</h2>
                    @Html.DropDownListFor(c => c.SelectableCategories.CategoryName, new SelectList(Model.SelectableCategories.Categories, "Text", "Value"), new { @class = "form-control" })
                </div>
                <p>
                    <button type="submit" class="btn btn-primary">Search By Category</button>
                </p>
            }
    
            @using (Html.BeginForm("FindProducts", "Products", FormMethod.Post, new { role = "form" }))
            {
                <div class="form-group">
                    <h2>Subcategories</h2>
                    @Html.DropDownListFor(s => s.SelectableSubcategories.SubcategoryName, new SelectList(Model.SelectableSubcategories.Subcategories, "Text", "Value"), new { @class = "form-control" })
                </div>
                <p>
                    <button type="submit" class="btn btn-primary">Search By Subcategory</button>
                </p>
            }
    
            @using (Html.BeginForm("FindProducts", "Products", FormMethod.Post, new { role = "form" }))
            {
                <div class="form-group">
                    <h2>Product Name, Model Name, or Product Number</h2>
                    @Html.TextBoxFor(t => t.SearchString, new { @class = "form-control" })
                </div>
                <p>
                    <button type="submit" class="btn btn-primary">Search By Product Name, Model Name, or Product Number</button>
                </p>
            }
    
            <!--TODO: Table showing matching products/-->
    
        </div>
    </div>
    ```

16. In Solution Explorer, right-click **Adventure-Works** (not **Solution 'Adventure-Works'**), and then click **Properties**.

17. In the left pane, click **Web**.

18. On the **Web** page, under **Start Action**, click **Specific Page**, but leave the page name empty.

19. On the **File** menu, click **Save Selected Items**.

20. In Solution Explorer, expand **App\_Start**, and then double-click **RouteConfig.cs**.

21. In RouteConfig.cs, after the line that begins **routes.IgnoreRoute** on a new line, type the following code:

    ```csharp
    routes.MapRoute(
        name: "Home",
        url: "",
        defaults: new { controller = "Products", action = "FindProducts" }
    );
    ```

22. In Solution Explorer, expand **Views**, expand **Shared**, and then double-click **\_Layout.cshtml**.

23. In \_Layout.cshtml, edit the contents of so that it reads:

    ```HTML 
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>@ViewBag.Title Adventure-Works Cycles</title>
        @Styles.Render("~/Content/css")
        @Scripts.Render("~/bundles/modernizr")
    </head>
    <body>
        <div class="navbar navbar-inverse navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    @Html.ActionLink("Adventure-Works Product Catalog", "Index", "Home", new { area = "" }, new { @class = "navbar-brand" })
                </div>
                <div class="navbar-collapse collapse">
                    <ul class="nav navbar-nav">
                        <li>@Html.ActionLink("Home", "Index", "Home")</li>
                        <li>@Html.ActionLink("Catalog", "FindProducts", "Products")</li>
                        <li>@Html.ActionLink("About", "About", "Home")</li>
                        <li>@Html.ActionLink("Contact", "Contact", "Home")</li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="container body-content">
            @RenderBody()
            <hr />
            <footer>
                <p>&copy; @DateTime.Now.Year - Adventure-Works Cycles</p>
            </footer>
        </div>
    
        @Scripts.Render("~/bundles/jquery")
        @Scripts.Render("~/bundles/bootstrap")
        @RenderSection("scripts", required: false)
    </body>
    </html>
    ```

24. Press F5 to build and run the web application.

25. Verify that the **Product Catalog** page appears. The **Categories** and **Subcategories** lists should be populated (click the drop-down lists to see the data). Note that if you click any of the buttons, you will currently receive an error because you have not implemented the code that handles the POST request yet.

26. Close the web application.

#### Task 5: Extend the Products Controller to Fetch and Display Product Data

1.  In Visual Studio, in Solution Explorer, double-click **ProductsController.cs**.

2.  In ProductsController.cs, after the **FindProductsAsync** method, type the following code:

    ```csharp 
    // Method called as POST request from the various search buttons on the form
    [ActionName("FindProducts")]
    [HttpPost]
    public async Task<ActionResult> FindProductsAsync(ProductViewModel productViewModel)
    {
        // Construct a view model that matches the search criteria specified by the user
    
        IEnumerable<Product> products = null;
    
        if (productViewModel.SelectableCategories != null)
        {
            // User is searching by category
            products = await ProductsRepository<Product>.GetItemsAsync(p => p.ProductCategory.Category == productViewModel.SelectableCategories.CategoryName);
        }
        else if (productViewModel.SelectableSubcategories != null)
        {
            // User is searching by subcategory
            products = await ProductsRepository<Product>.GetItemsAsync(p => p.ProductCategory.Subcategory == productViewModel.SelectableSubcategories.SubcategoryName);
        }
        else
        {
            // User is searching by product name, model name, or product number
            products = await ProductsRepository<Product>.GetItemsAsync(p => 
                p.ProductName.Contains(productViewModel.SearchString) ||
                p.Model.Contains(productViewModel.SearchString) ||
                p.ProductNumber.Contains(productViewModel.SearchString));
        }
    
        // Construct a new view model containing the results and display it
        return View(new ProductViewModel
        {
            Products = products,
            SelectableCategories = Session["selectableCategories"] as ProductCategoryViewModel ?? await InitializeCategoriesAsync(),
            SelectableSubcategories = Session["selectableSubcategories"] as ProductSubcategoryViewModel ?? await InitializeSubCategoriesAsync()
        });
    }
    ```

3.  In Solution Explorer, double-click **FindProducts.cshtml** file.

4.  In FindProducts.cshtml, after **\<\!--TODO: Table showing matching products/--\>**, type the following code:

    ```HTML 
    <table class="table">
        <thead>
            <tr>
                <td>Product Number</td>
                <td>Product Name</td>
                <td>Model</td>
                <td></td>
            </tr>
        </thead>
        @foreach (var item in Model.Products)
        {
            <tr>
                <td>
                    @Html.DisplayFor(modelItem => item.ProductNumber)
                </td>
                <td>
                    @Html.DisplayFor(modelItem => item.ProductName)
                </td>
                <td>
                    @Html.DisplayFor(modelItem => item.Model)
                </td>
                <td>
                    @Html.ActionLink("Details", "GetProductDetails", new { productID = item.ProductID })
                </td>
            </tr>
        }
    </table>
    ```

5.  Press F5 to build and run the web application.

6.  When the application starts, in the **Categories** list, click **Components**, and then click **Search By Category**. The view should now display all products that match that category.

7.  In the **Subcategories** list, click **Road Bikes**, and then click **Search By Subcategory**. This time the view should display only those products in that subcategory.

8.  In the **Product Name, Model Name, or Product Number** box, type **Wash**, and then click **Search By Product Name, Model Name, or Product Number**. You should now be presented with all products that contain the text **Wash** in the product number, name, or model.

9.  If you click the **Details** link for a product, the application will currently report an error because you haven't implemented the **GetProductDetails** method yet.

10. Close the web application and return to Visual Studio.

11. On the **ProductsController.cs** tab, after the second **FindProductsAsync** method (that you added earlier in this exercise), type the following code:

    ```csharp 
    // Method called to display the details of the specified product
    [ActionName("GetProductDetails")]
    [HttpGet]
    public async Task<ActionResult> GetProductDetailsAsync(string productID)
    {
        // Find the data for the specified product
        var products = await ProductsRepository<Product>.GetItemsAsync(p => p.ProductID == productID);
    
        // Display the details of the product
        return View(products.First());
    }
    ```

12. In Solution Explorer, expand **Views**, right-click **Products**, point to **Add**, and then click **View**.

13. In the **Add View** dialog box, in the **View name** box, type **GetProductDetails**.

14. In the **Template** box, click **Empty (without model)**, and then ensure **Use a layout page** is selected.

15. In the **Use a layout page** box, type **\~/Views/Shared/\_Layout.cshtml**, and then click **Add**.

16. In GetProductDetails.cshtml, edit the contents of the file so that it reads:

    ```HTML 
    @model Adventure_Works.Models.Product
    
    @{
        ViewBag.Title = "Products";
        Layout = "~/Views/Shared/_Layout.cshtml";
    }
    
    <h1>Product Details</h1>
    ```

17. Type the following code:

    ```HTML 
    <div class="panel panel-default">
        <div class="panel panel-body">
            <div class="form-group">
                <table class="table">
                    <tr>
                        <td>Product Number: </td>
                        <td>@Html.DisplayTextFor(p => p.ProductNumber)</td>
                    </tr>
                    <tr>
                        <td>Product Name: </td>
                        <td>@Html.DisplayTextFor(p => p.ProductName)</td>
                    </tr>
                    <tr>
                        <td>Model: </td>
                        <td>@Html.DisplayTextFor(p => p.Model)</td>
                    </tr>
                    <tr>
                        <td>Description: </td>
                        <td>@Html.DisplayTextFor(p => p.Description)</td>
                    </tr>
                    <tr>
                        <td>Price: </td>
                        @if (Model.ListPrice == 0)
                        {
                            <td><p>Contact Adventure-Works for price information</p></td>
                        }
                        else
                        {
                            <td>@Html.DisplayTextFor(p => p.ListPrice)</td>
                        }
                    </tr>
                    <tr>
                        <td>Color: </td>
                        <td>@Html.DisplayTextFor(p => p.Color)</td>
                    </tr>
                    <tr>
                        <td>Size: </td>
                        <td>@Html.DisplayTextFor(p => p.Size)</td>
                    </tr>
                    <tr>
                        <td>Weight: </td>
                        <td>@Html.DisplayTextFor(p => p.Weight)</td>
                    </tr>
                    <tr>
                        <td>In Stock: </td>
                        <td>@Html.DisplayTextFor(p => p.QuantityInStock)</td>
                    </tr>
                    @if (Model.Documentation.Document.Length > 0)
                    {
                        <tr>
                            <td>Documents: </td>
                            <td>
                                @Html.DisplayTextFor(p => p.Documentation)
                                <a href="@Model.Documentation.Document">Click to download</a>
                            </td>
                        </tr>
                    }
                    <tr>
                        <td>Image: </td>
                        <td>
                            <img src="@Model.Images.LargePhoto" />
                        </td>
                    </tr>
                </table>
            </div>
        </div>
    </div>
    ```

18. Press F5 to build and run the web app.

19. When the application starts, in the **Categories** list, click **Components**, and then click **Search By Category**.

20. From the results list, click any of the **Details** links to view the product details.

21. Close the web application.

**Result**: At the end of this exercise, you should have created an application that you can use to query product information.

### Exercise 4: Maintaining Stock Levels in the Product Catalog

#### Task 1: Create a Collection and Repository for Storing Back Orders

1.  In Internet Explorer, in the **SQL API** pane, right-click **SalesData**, and then click **New Collection**.

2.  On the **Add Collection** blade, in the **Collection Id** box, type **BackOrders**, and then click **Unlimited**.

3.  In the **Partition key** box, type **/productid**.

4.  In the **Throughput (400 - 1,000,000 RU/s)** box, type **1000**, and then click **OK**.

5.  In Visual Studio, on the **File** menu, point to **Open**, and then click **Project/Solution**.

6.  In the **Open Project** dialog box, in the **File name** box, type **E:\\Labfiles\\Lab02\\Starter\\Adventure-Works-Ex4\\Adventure-Works.sln**, and then click **Open**.

7.  In the **Security Warning for MigrateProductData** dialog box, clear the **Ask me for every project in this solution** check box, click **OK**.

8.  In Solution Explorer, double-click **Web.config**.

9.  In Web.config, in the value of the **EndpointUrl** key, paste the **URI** value you noted earlier, replacing the text **\~URL\~**.

10. In Web.config, in the value of the **PrimaryKey** key, paste the **PRIMARY KEY** value you noted earlier, replacing the text **\~PRIMARY KEY\~**.

11. In Web.config, add the following setting to the list of app settings:

    ```XML 
    <appSettings>
    ...
    <add key="BackOrderCollection" value="BackOrders"/>
    ...
    </appSettings>
    ```

12. In Solution Explorer, expand **Models**, and then double-click **Product.cs**.

13. In Product.cs, after the definition of the **Product** class, type the following code:

    ```csharp 
    public class ProductBackOrder
    {
        [JsonProperty("id")]
        public string BackOrderID { get; set; }
    
        [JsonProperty("productid")]
        public string ProductID { get; set; }
    
        [JsonProperty("productname")]
        public string ProductName { get; set; }
    
        [JsonProperty("productnumber")]
        public string ProductNumber { get; set; }
    
        [JsonProperty("numberonbackorder")]
        public int NumberOnBackOrder { get; set; }
    
        [JsonProperty("backorderdate")]
        public DateTime BackOrderDate { get; set; } 
    }
    ```

14. In Solution Explorer, double-click **Global.asax**.

15. In global.asax.cs, edit the **Application\_Start** method to add the following line:

    ```csharp 
        ProductsRepository<Adventure_Works.Models.ProductBackOrder>.Initialize(ConfigurationManager.AppSettings["BackOrderCollection"]);
    ```
    
    When you have finished, the **Application\_Start** method should look like this:
    
    ```csharp 
            protected void Application_Start()
        {
            AreaRegistration.RegisterAllAreas();
            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
            RouteConfig.RegisterRoutes(RouteTable.Routes);
            BundleConfig.RegisterBundles(BundleTable.Bundles);
            ProductsRepository<Adventure_Works.Models.Product>.Initialize(ConfigurationManager.AppSettings["ProductsCollection"]);
            ProductsRepository<Adventure_Works.Models.ProductCategoryData>.Initialize(ConfigurationManager.AppSettings["CategoriesCollection"]);
            ProductsRepository<Adventure_Works.Models.ProductBackOrder>.Initialize(ConfigurationManager.AppSettings["BackOrderCollection"]);
        }
    ```

#### Task 2: Extend the Repository Class to Enable Document Creation and Update

1.  In Solution Explorer, double-click **ProductsRepository.cs**.

2.  In ProductsRepository.cs, at the beginning of the file, type the following code:

    ```csharp 
    using System.Net;
    using Microsoft.Azure.Documents;
    ```

3.  At the end of the **ProductsRepository\<T\>** class, type the following code:

    ```csharp 
    public static async Task<bool> CreateItem(T item)
    {
        // Add the new document to the collection
        Uri collectionUri = UriFactory.CreateDocumentCollectionUri(database, collection);
        var response = await client.CreateDocumentAsync(collectionUri, item);
    
        // Examine the status of the response, to determine whether the document was created successfully or not
        return response.StatusCode == HttpStatusCode.Created;
    }
    ```

4.  Type the following code:

    ```csharp 
    public static async Task<int> IncrementNumericValueInDocumentAsync(string docID, string property, int value, string partitionKey = null)
    {
        // Fetch the doc to be updated
        Uri docUri = UriFactory.CreateDocumentUri(database, collection, docID);
        var options = partitionKey == null ? null : new RequestOptions
        {
            PartitionKey = new PartitionKey(partitionKey)
        };
    
        var response = await client.ReadDocumentAsync(docUri, options);
        var doc = response.Resource;
    
        // Change the value of the specified property
        var propVal = doc.GetPropertyValue<int>(property);
        propVal += value;
        doc.SetPropertyValue(property, propVal);
    
        // Attempt to write the modified document back to the database
        // If another user modifies the same doc at the same time, this code will throw an exception back to the caller where it should be handled
        options = new RequestOptions
        {
            AccessCondition = new AccessCondition
            {
                Condition = doc.ETag,
                Type = AccessConditionType.IfMatch
            }
        };
        response = await client.ReplaceDocumentAsync(doc.SelfLink, doc, options);
    
        // Return the new value of the property that was updated
        return propVal;
    }
    ```

#### Task 3: Add Buy Functionality to the Product Details View

1.  In Solution Explorer, expand **Views**, expand **Products**, and then double-click **GetProductDetails.cshtml**.

2.  In GetProductDetails.cshtml, after the closing **\</table\>** tag (line 72), type the following code:

    ```HTML 
    @using (Html.BeginForm("BuyProduct", "Products", FormMethod.Post, new { role = "form" }))
    {
        <div class="form-group">
            <p>Number Required:
            <input name="productID" type="hidden" value="@Model.ProductID" />
            <input name="subcategory" type="hidden" value="@Model.ProductCategory.Subcategory" />
            <input name="productName" type="hidden" value="@Model.ProductName" />
            <input name="productNumber" type="hidden" value="@Model.ProductNumber" />
            <input id="numRequired" name="numRequired" class="form-control" type="number" value="1" min="1"/></p>
            <p>
                <button type="submit" class="btn btn-primary">Purchase</button>
            </p>
        </div>
    }
    ```

3.  At the end of the file, type the following code:

    ```CSS 
    <style>
        #numRequired {
            width: 6em;
        }
    </style>
    ```

4.  In Solution Explorer, expand **Controllers**, and then double-click **ProductsController.cs**.

5.  In ProductsController.cs, after the definition of the **GetProductDetailsAsync** class, type the following code:

    ```csharp 
    // Method called when the user wishes to purchase a product
    [ActionName("BuyProduct")]
    [HttpPost]
    public async Task<ActionResult> BuyProductAsync(string productID, string subcategory, string productName, string productNumber, int numRequired)
    {
        // Use the repository to update the database and return the new stock level
        int newStockLevel = await ProductsRepository<Product>.IncrementNumericValueInDocumentAsync(productID, "quantityinstock", -numRequired, subcategory);
    
        // If the new stock level is now negative, undo the update and place a back order instead (Adventure-Works currently doesn't allow split orders)
        if (newStockLevel < 0)
        {
            await ProductsRepository<Product>.IncrementNumericValueInDocumentAsync(productID, "quantityinstock", numRequired, subcategory);
            var backOrder = new ProductBackOrder
            {
                BackOrderID = Guid.NewGuid().ToString(),
                ProductID = productID,
                ProductName = productName,
                ProductNumber = productNumber,
                NumberOnBackOrder = numRequired,
                BackOrderDate = DateTime.UtcNow
            };
    
            await ProductsRepository<ProductBackOrder>.CreateItem(backOrder);
        }
        return View(newStockLevel);
    }
    ```

6.  In Solution Explorer, expand **Views**, right-click **Products**, point to **Add**, and then click **View**.

7.  In the **Add View** dialog box, in the **View name** box, type **BuyProduct**.

8.  In the **Template** box, click **Empty (without model)**, and ensure that **Use a layout page** is selected.

9.  In the **Use a layout page** box, type **\~/Views/Shared/\_Layout.cshtml**, and then click **Add**.

10. In BuyProduct.cshtml, edit the contents so that it reads:

    ```HTML 
    @model int
    
    @{
        ViewBag.Title = "Products";
        Layout = "~/Views/Shared/_Layout.cshtml";
    }
    
    <h1>Product Details</h1>
    <div class="panel panel-default">
        <div class="panel panel-body">
            @if (Model < 0)
            {
                <p>Backorder created</p>
            } else
            {
                <p>Order placed</p>
            }
        </div>
    </div>
    ```

11. Press F5 to build and run the web app.

12. When the application starts, in the **Categories** list, click **Components**, and then click **Search By Category**.

13. In the results list, click any of the **Details** links to view the product details.

14. Click **Purchase** to purchase an item; you should see the message **Order placed**.

15. Click the browser back button.

16. In the **Number Required** box, type **5000**, and then click **Purchase**. You should see the message **Backorder created**.

17. Close the web application, then close Visual Studio.

18. In Internet Explorer, on the **SQL API** pane, expand **SalesData**, expand **BackOrders**, and then click **Documents**. Observe that a back order document was created.

#### Task 4: Lab Close Down

To reduce your costs delete the resource group containing your Cosmos DB databases:

1.  In Internet Explorer, in the Azure Portal, click **Resource groups**.

2.  Right-click the **20777\_Mod02** resource group, and then click **Delete resource group**.

3.  On the **Are you sure you want to delete "20777\_Mod02"?** blade, in the **Type the resource group name:** box, type **20777\_Mod02**, and then click **Delete**.

4.  When you have finished, close Internet Explorer.

**Result**: In this lab, you have used what you have learned in this lesson to design a document schema, load data into a collection, and to query, modify, and delete documents in a collection.

---
Â© 2018 Microsoft Corporation. All rights reserved.

The text in this document is available under the [Creative Commons Attribution 3.0 License](https://creativecommons.org/licenses/by/3.0/legalcode), additional terms may apply. All other content contained in this document (including, without limitation, trademarks, logos, images, etc.) are **not** included within the Creative Commons license grant. This document does not provide you with any legal rights to any intellectual property in any Microsoft product. You may copy and use this document for your internal, reference purposes.

This document is provided "as-is." Information and views expressed in this document, including URL and other Internet Web site references, may change without notice. You bear the risk of using it. Some examples are for illustration only and are fictitious. No real association is intended or inferred. Microsoft makes no warranties, express or implied, with respect to the information provided here.
